src/Demo/src/main.cpp:39:5: style: Class 'DemoApplication' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DemoApplication(const Nexus::ApplicationSpecification &spec)
    ^
src/Editor/UI/Dialogs/NewProjectDialog.cpp:58:56: style: Variable 'fullpath' is assigned a value that is never used. [unreadVariable]
                        std::filesystem::path fullpath = directory + std::string("\\") + m_Name + extension;
                                                       ^
src/Editor/UI/Layout.cpp:22:9: performance: Variable 'm_ImGuiRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_ImGuiRenderer = std::make_unique<Nexus::ImGuiUtils::ImGuiGraphicsRenderer>(app);
        ^
src/Editor/UI/Layout.hpp:27:14: performance:inconclusive: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void OpenProject();
             ^
src/Editor/UI/Layout.cpp:193:18: note: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace).
    void Layout::OpenProject()
                 ^
src/Editor/UI/Layout.hpp:27:14: note: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace).
        void OpenProject();
             ^
src/Nexus/src/Nexus-Core/Graphics/Pipeline.hpp:52:13: performance: Variable 'm_Description' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_Description = description;
            ^
src/Nexus/src/Nexus-Core/Application.cpp:268:9: performance: Variable 'm_Specification' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Specification = spec;
        ^
src/Nexus/src/Nexus-Core/Point.hpp:81:14: style:inconclusive: Technically the member function 'Nexus::Point3D::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y, T *z)
             ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:55:34: style:inconclusive: Technically the member function 'Nexus::Graphics::VertexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:79:34: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:81:27: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetFormat' can be const. [functionConst]
        IndexBufferFormat GetFormat() { return m_Format; }
                          ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:108:34: style:inconclusive: Technically the member function 'Nexus::Graphics::UniformBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:91:13: style:inconclusive: Technically the member function 'Nexus::Graphics::Framebuffer::GetColorTextureCount' can be const. [functionConst]
        int GetColorTextureCount() { return m_Specification.ColorAttachmentSpecification.Attachments.size(); }
            ^
src/Nexus/src/Nexus-Core/Graphics/Swapchain.hpp:30:39: style:inconclusive: Technically the member function 'Nexus::Graphics::Swapchain::GetSpecification' can be const. [functionConst]
        const SwapchainSpecification &GetSpecification()
                                      ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:48:26: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::GetType' can be const. [functionConst]
        RenderTargetType GetType()
                         ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:107:14: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::IsValid' can be const. [functionConst]
        bool IsValid()
             ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:112:24: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::operator==' can be const. [functionConst]
        constexpr bool operator==(const RenderTarget &other)
                       ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.hpp:72:21: style:inconclusive: Technically the member function 'Nexus::Graphics::GraphicsDevice::GetGraphicsAPI' can be const. [functionConst]
        GraphicsAPI GetGraphicsAPI() { return this->m_API; }
                    ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < uint32_t >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < int >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:66:9: style: Struct 'Point3D' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point3D(T x)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:22:9: style: Struct 'FramebufferTextureSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferTextureSpecification(PixelFormat format)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:37:9: style: Struct 'FramebufferColorAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferColorAttachmentSpecification(std::initializer_list<FramebufferTextureSpecification> attachments)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:52:9: style: Struct 'FramebufferDepthAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferDepthAttachmentSpecification(PixelFormat format)
        ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < uint32_t >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Application.cpp:623:32: style: Variable 'indexToRemove' is assigned a value that is never used. [unreadVariable]
        uint32_t indexToRemove = 0;
                               ^
src/Nexus/src/Nexus-Core/AssetManager.hpp:17:9: style: Class 'AssetManager' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AssetManager(Graphics::GraphicsDevice *graphicsDevice) : m_GraphicsDevice(graphicsDevice) {}
        ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:10:52: performance: Function parameter 'filters' should be passed by const reference. [passedByValue]
    const char *OpenFile(std::vector<const char *> filters)
                                                   ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:22:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:32:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
src/Nexus/src/Nexus-Core/Graphics/Font.hpp:91:46: style:inconclusive: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const. [functionConst]
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
src/Nexus/src/Nexus-Core/Graphics/Font.cpp:140:48: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
    Nexus::Ref<Nexus::Graphics::Texture> Font::GetTexture()
                                               ^
src/Nexus/src/Nexus-Core/Graphics/Font.hpp:91:46: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:13:27: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const. [functionConst]
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:32:39: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
    Ref<VertexBuffer> FullscreenQuad::GetVertexBuffer()
                                      ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:13:27: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:14:26: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const. [functionConst]
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:37:38: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
    Ref<IndexBuffer> FullscreenQuad::GetIndexBuffer()
                                     ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:14:26: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:16:45: performance:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:42:57: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
    Nexus::Graphics::VertexBufferLayout FullscreenQuad::GetVertexBufferLayout()
                                                        ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:16:45: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:20:9: performance: Variable 'm_API' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_API = createInfo.API;
        ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:52:24: style: Variable 'totalTime' is assigned a value that is never used. [unreadVariable]
        auto totalTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
                       ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:37:21: style: Unused variable: errorMessage [unusedVariable]
        std::string errorMessage;
                    ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:76:50: style:inconclusive: Boolean expression 'language==ShaderLanguage::GLSL' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.hpp:74:27: performance:inconclusive: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:291:40: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
    CompilationResult ShaderGenerator::Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources)
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.hpp:74:27: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:76:50: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:321:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:321:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:333:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:333:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:345:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:345:39: note: Shadow variable
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:369:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:369:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:385:31: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            shaderc::Compiler compiler;
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:385:31: note: Shadow variable
            shaderc::Compiler compiler;
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:386:18: style: Local variable 'shaderType' shadows outer variable [shadowVariable]
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:301:14: note: Shadowed declaration
        auto shaderType = GetTypeOfShader(options.Stage);
             ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:386:18: note: Shadow variable
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:387:40: style: Local variable 'result' shadows outer variable [shadowVariable]
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:302:36: note: Shadowed declaration
        shaderc::CompilationResult result = compiler.CompileGlslToSpv(source, shaderType, options.ShaderName.c_str());
                                   ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:387:40: note: Shadow variable
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:389:35: style: Local variable 'spirv_binary' shadows outer variable [shadowVariable]
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:310:31: note: Shadowed declaration
        std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:389:35: note: Shadow variable
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:35:33: style:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::GetPipeline' can be const. [functionConst]
        Ref<Graphics::Pipeline> GetPipeline() { return m_Pipeline; }
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:44:14: performance:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void UpdateMonitors();
             ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:719:33: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
    void ImGuiGraphicsRenderer::UpdateMonitors()
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:44:14: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
        void UpdateMonitors();
             ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:25:9: style: Class 'ImGuiGraphicsRenderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ImGuiGraphicsRenderer(Nexus::Application *app);
        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:205:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:217:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:230:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:243:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:256:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:269:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:283:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:296:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:308:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:321:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:336:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:431:45: style: C-style pointer casting [cstyleCast]
                    ImGuiWindowInfo *info = (ImGuiWindowInfo *)platform_io.Viewports[i]->PlatformUserData;
                                            ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:599:33: style: C-style pointer casting [cstyleCast]
        ImGuiWindowInfo *info = (ImGuiWindowInfo *)drawData->OwnerViewport->PlatformUserData;
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:539:56: style: Variable 'layout' is assigned a value that is never used. [unreadVariable]
            Nexus::Graphics::VertexBufferLayout layout =
                                                       ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:617:27: style: Variable 'vp' is assigned a value that is never used. [unreadVariable]
        ImGuiViewport *vp = drawData->OwnerViewport;
                          ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:164:24: style:inconclusive: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const. [functionConst]
        const uint32_t GetControllerIndex();
                       ^
src/Nexus/src/Nexus-Core/Input/Gamepad.cpp:199:29: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
    const uint32_t Gamepad::GetControllerIndex()
                            ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:164:24: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
        const uint32_t GetControllerIndex();
                       ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:93:9: style: Class 'Gamepad' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Gamepad(uint32_t index);
        ^
src/Nexus/src/Nexus-Core/Input/Mouse.hpp:37:5: style: The class 'Mouse' does not have a constructor although it has private member variables. [noConstructor]
    class Mouse
    ^
src/Nexus/src/Nexus-Core/Input/InputState.hpp:19:5: style: The class 'InputState' does not have a constructor although it has private member variables. [noConstructor]
    class InputState
    ^
src/Nexus/src/Nexus-Core/Input/Input.hpp:176:14: performance:inconclusive: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Input.cpp:234:17: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
    void Input::CacheInput()
                ^
src/Nexus/src/Nexus-Core/Input/Input.hpp:176:14: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Keyboard.hpp:133:14: style:inconclusive: Technically the member function 'Nexus::Keyboard::CacheInput' can be const. [functionConst]
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Keyboard.cpp:5:20: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
    void Keyboard::CacheInput()
                   ^
src/Nexus/src/Nexus-Core/Input/Keyboard.hpp:133:14: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:67:28: style: Unused private function: 'Logger::GetTime' [unusedPrivateFunction]
        static std::string GetTime();
                           ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:62:40: style:inconclusive: Technically the member function 'Nexus::Logger::GetLogs' can be const. [functionConst]
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
src/Nexus/src/Nexus-Core/Logging/Log.cpp:64:44: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
    const std::vector<Nexus::Log> &Logger::GetLogs()
                                           ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:62:40: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
src/Nexus/src/Nexus-Core/Renderer.hpp:17:14: performance:inconclusive: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void End();
             ^
src/Nexus/src/Nexus-Core/Renderer.cpp:10:20: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
    void Renderer::End()
                   ^
src/Nexus/src/Nexus-Core/Renderer.hpp:17:14: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
        void End();
             ^
src/Nexus/src/Nexus-Core/Renderer.hpp:28:9: style: Class 'Renderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Renderer(Graphics::GraphicsDevice *device);
        ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:106:50: style:inconclusive: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list. [initializerList]
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.cpp:513:53: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        : m_Device(device), m_RenderTarget(target), m_CommandList(m_Device->CreateCommandList())
                                                    ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:106:50: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:100:14: style:inconclusive: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const. [functionConst]
        void EnsureStarted();
             ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.cpp:1150:25: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
    void BatchRenderer::EnsureStarted()
                        ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:100:14: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
        void EnsureStarted();
             ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < float >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < float >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Runtime/Entity.hpp:20:14: performance:inconclusive: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        bool Deserialize(YAML::Node &data);
             ^
src/Nexus/src/Nexus-Core/Runtime/Entity.cpp:38:18: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
    bool Entity::Deserialize(YAML::Node &data)
                 ^
src/Nexus/src/Nexus-Core/Runtime/Entity.hpp:20:14: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
        bool Deserialize(YAML::Node &data);
             ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:17:9: performance: Variable 'm_SceneDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SceneDirectory = "\\Scenes";
        ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:18:9: performance: Variable 'm_AssetsDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_AssetsDirectory = "\\Assets";
        ^
src/Nexus/src/Nexus-Core/Runtime/Project.hpp:36:14: style:inconclusive: Technically the member function 'Nexus::Project::WriteProjectFile' can be const. [functionConst]
        void WriteProjectFile();
             ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:97:19: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
    void Project::WriteProjectFile()
                  ^
src/Nexus/src/Nexus-Core/Runtime/Project.hpp:36:14: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
        void WriteProjectFile();
             ^
src/Nexus/src/Nexus-Core/Runtime/Scene.hpp:23:14: style:inconclusive: Technically the member function 'Nexus::Scene::Serialize' can be const. [functionConst]
        void Serialize(const std::string &filepath);
             ^
src/Nexus/src/Nexus-Core/Runtime/Scene.cpp:119:17: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
    void Scene::Serialize(const std::string &filepath)
                ^
src/Nexus/src/Nexus-Core/Runtime/Scene.hpp:23:14: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
        void Serialize(const std::string &filepath);
             ^
src/Nexus/src/Nexus-Core/UI/Canvas.cpp:9:9: performance: Variable 'm_BatchRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_BatchRenderer = std::make_unique<Nexus::Graphics::BatchRenderer>(device, Nexus::Graphics::RenderTarget{swapchain});
        ^
src/Nexus/src/Nexus-Core/Vertex.hpp:46:9: style: Struct 'VertexBufferLayout' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexBufferLayout(std::initializer_list<VertexBufferElement> elements)
        ^
src/Nexus/src/Nexus-Core/Vertex.hpp:111:9: style: Struct 'VertexPosition' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexPosition(const glm::vec3 &position)
        ^
src/Nexus/src/Nexus-Core/Window.hpp:80:14: style:inconclusive: Technically the member function 'Nexus::Window::IsClosing' can be const. [functionConst]
        bool IsClosing();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:68:18: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
    bool Window::IsClosing()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:80:14: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
        bool IsClosing();
             ^
src/Nexus/src/Nexus-Core/Window.hpp:100:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetIsMouseVisible(bool visible);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:122:18: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
    void Window::SetIsMouseVisible(bool visible)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:100:14: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
        void SetIsMouseVisible(bool visible);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:104:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetCursor(Cursor cursor);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:135:18: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
    void Window::SetCursor(Cursor cursor)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:104:14: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
        void SetCursor(Cursor cursor);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:108:27: style:inconclusive: Technically the member function 'Nexus::Window::GetInput' can be const. [functionConst]
        const InputState *GetInput();
                          ^
src/Nexus/src/Nexus-Core/Window.cpp:182:31: note: Technically the member function 'Nexus::Window::GetInput' can be const.
    const InputState *Window::GetInput()
                              ^
src/Nexus/src/Nexus-Core/Window.hpp:108:27: note: Technically the member function 'Nexus::Window::GetInput' can be const.
        const InputState *GetInput();
                          ^
src/Nexus/src/Nexus-Core/Window.hpp:153:18: style:inconclusive: Technically the member function 'Nexus::Window::GetID' can be const. [functionConst]
        uint32_t GetID();
                 ^
src/Nexus/src/Nexus-Core/Window.cpp:298:22: note: Technically the member function 'Nexus::Window::GetID' can be const.
    uint32_t Window::GetID()
                     ^
src/Nexus/src/Nexus-Core/Window.hpp:153:18: note: Technically the member function 'Nexus::Window::GetID' can be const.
        uint32_t GetID();
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:157:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:308:18: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
    void Window::SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:157:14: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:158:14: performance:inconclusive: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StartTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:318:18: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StartTextInput()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:158:14: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
        void StartTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.hpp:159:14: performance:inconclusive: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StopTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:322:18: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StopTextInput()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:159:14: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
        void StopTextInput();
             ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.hpp:17:9: style: Class 'CommandListD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListD3D12(GraphicsDeviceD3D12 *device);
        ^
src/Nexus/src/Platform/D3D12/TimingQueryD3D12.hpp:14:9: style: Class 'TimingQueryD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryD3D12(GraphicsDeviceD3D12 *device);
        ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:178:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)target.GetData<Swapchain *>();
                                  ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:236:31: style: C-style pointer casting [cstyleCast]
        auto swapchainD3D12 = (SwapchainD3D12 *)target;
                              ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:431:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)m_CurrentRenderTarget.GetData<Swapchain *>();
                                  ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:74:54: style:inconclusive: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'. [funcArgNamesDifferent]
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.hpp:25:48: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
        virtual void SetPipeline(Ref<Pipeline> ipeline) override;
                                               ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:74:54: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
src/Nexus/src/Platform/D3D12/FramebufferD3D12.cpp:61:26: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        auto d3d12Device = m_Device->GetDevice();
                         ^
src/Nexus/src/Platform/D3D12/SamplerD3D12.hpp:13:9: style: Class 'SamplerD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerD3D12(const SamplerSpecification &spec);
        ^
src/Nexus/src/Platform/D3D12/GraphicsDeviceD3D12.cpp:22:37: style: Variable 'experimentalFeatures' is assigned a value that is never used. [unreadVariable]
        UUID experimentalFeatures[] = {D3D12ExperimentalShaderModels};
                                    ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.hpp:35:29: style:inconclusive: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list. [initializerList]
        PipelineDescription m_Description;
                            ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.cpp:14:52: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        : Pipeline(description), m_Device(device), m_Description(description)
                                                   ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.hpp:35:29: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        PipelineDescription m_Description;
                            ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.cpp:161:30: style: C-style pointer casting [cstyleCast]
            auto swapchain = (SwapchainD3D12 *)m_Description.Target.GetData<Swapchain *>();
                             ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:142:18: style: Local variable 'd3d12Device' shadows outer variable [shadowVariable]
            auto d3d12Device = m_Device->GetDevice();
                 ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:114:20: note: Shadowed declaration
        const auto d3d12Device = m_Device->GetDevice();
                   ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:142:18: note: Shadow variable
            auto d3d12Device = m_Device->GetDevice();
                 ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:20:38: style: Variable 'constantBufferCount' is assigned a value that is never used. [unreadVariable]
        uint32_t constantBufferCount = spec.UniformBuffers.size();
                                     ^
src/Nexus/src/Platform/D3D12/SamplerD3D12.cpp:12:9: performance: Variable 'm_SamplerFilter' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SamplerFilter = GetD3D12Filter(spec.SampleFilter);
        ^
src/Nexus/src/Platform/D3D12/ShaderModuleD3D12.cpp:67:26: style: Variable 'hr' is assigned a value that is never used. [unreadVariable]
        const HRESULT hr = compiler->Compile(
                         ^
src/Nexus/src/Platform/D3D12/SwapchainD3D12.cpp:11:20: style: C-style pointer casting [cstyleCast]
        m_Device = (GraphicsDeviceD3D12 *)device;
                   ^
src/Nexus/src/Platform/D3D12/TimingQueryD3D12.cpp:10:37: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        ID3D12Device10 *d3d12Device = m_Device->GetDevice();
                                    ^
src/Nexus/src/Platform/OpenAL/AudioSourceOpenAL.hpp:17:9: style: Class 'AudioSourceOpenAL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AudioSourceOpenAL(Ref<AudioBuffer> buffer);
        ^
src/Nexus/src/Platform/OpenAL/AudioDeviceOpenAL.cpp:89:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
src/Nexus/src/Platform/OpenAL/AudioDeviceOpenAL.cpp:105:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
src/Nexus/src/Platform/OpenAL/AudioSourceOpenAL.cpp:11:9: performance: Variable 'm_Buffer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Buffer = buffer;
        ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.hpp:30:14: performance:inconclusive: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void ExecuteCommand(ClearColorTargetCommand command, GraphicsDeviceOpenGL *device);
             ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.cpp:236:33: note: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace).
    void CommandExecutorOpenGL::ExecuteCommand(ClearColorTargetCommand command, GraphicsDeviceOpenGL *device)
                                ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.hpp:30:14: note: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace).
        void ExecuteCommand(ClearColorTargetCommand command, GraphicsDeviceOpenGL *device);
             ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.hpp:31:14: performance:inconclusive: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void ExecuteCommand(ClearDepthStencilTargetCommand command, GraphicsDeviceOpenGL *device);
             ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.cpp:251:33: note: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace).
    void CommandExecutorOpenGL::ExecuteCommand(ClearDepthStencilTargetCommand command, GraphicsDeviceOpenGL *device)
                                ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.hpp:31:14: note: Technically the member function 'Nexus::Graphics::CommandExecutorOpenGL::ExecuteCommand' can be static (but you may consider moving to unnamed namespace).
        void ExecuteCommand(ClearDepthStencilTargetCommand command, GraphicsDeviceOpenGL *device);
             ^
src/Nexus/src/Platform/OpenGL/PipelineOpenGL.hpp:13:9: style: Class 'PipelineOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        PipelineOpenGL(const PipelineDescription &description);
        ^
src/Nexus/src/Platform/OpenGL/TextureOpenGL.hpp:13:9: style: Class 'TextureOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TextureOpenGL(const TextureSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/ResourceSetOpenGL.hpp:17:9: style: Class 'ResourceSetOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ResourceSetOpenGL(const ResourceSetSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.cpp:320:38: style: C-style pointer casting [cstyleCast]
        SwapchainOpenGL *swapchain = (SwapchainOpenGL *)command.Target;
                                     ^
src/Nexus/src/Platform/OpenGL/CommandListOpenGL.hpp:19:9: style: Class 'CommandListOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListOpenGL(GraphicsDevice *device);
        ^
src/Nexus/src/Platform/OpenGL/SamplerOpenGL.hpp:12:9: style: Class 'SamplerOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerOpenGL(const SamplerSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/GraphicsDeviceOpenGL.cpp:158:28: style: C-style pointer casting [cstyleCast]
        auto glSwapchain = (SwapchainOpenGL *)swapchain;
                           ^
src/Nexus/src/Platform/Vulkan/CommandListVk.hpp:14:9: style: Class 'CommandListVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListVk(GraphicsDeviceVk *graphicsDevice);
        ^
src/Nexus/src/Platform/Vulkan/TimingQueryVk.hpp:14:9: style: Class 'TimingQueryVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryVk(GraphicsDeviceVk *device);
        ^
src/Nexus/src/Platform/Vulkan/CommandListVk.cpp:300:36: style: C-style pointer casting [cstyleCast]
            auto vulkanSwapchain = (SwapchainVk *)swapchain;
                                   ^
src/Nexus/src/Platform/Vulkan/CommandListVk.cpp:445:28: style: C-style pointer casting [cstyleCast]
        auto swapchainVk = (SwapchainVk *)target;
                           ^
src/Nexus/src/Platform/Vulkan/FramebufferVk.cpp:113:25: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            attachments.push_back(texture->GetImageView());
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:37:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:187:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:382:38: style: C-style pointer casting [cstyleCast]
            SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                     ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:470:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:710:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:707:25: note: result is initialized
        VkResult result = vkEnumerateInstanceExtensionProperties(nullptr, &count, nullptr);
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:710:16: note: result is overwritten
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:740:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:737:25: note: result is initialized
        VkResult result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, nullptr);
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:740:16: note: result is overwritten
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:720:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:750:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:34:31: style: Variable 'deviceExtensions' is assigned a value that is never used. [unreadVariable]
        auto deviceExtensions = GetSupportedDeviceExtensions();
                              ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:156:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:251:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:19:21: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            layouts.push_back(layout.second);
                    ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:30:44: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[textureBinding.Set] = {};
                                           ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:36:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:55:50: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[uniformBufferBinding.Set] = {};
                                                 ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:61:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:39:32: style: Variable 'samplerInfo.mipLodBias' is reassigned a value before the old one has been used. [redundantAssignment]
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:38:32: note: samplerInfo.mipLodBias is assigned
        samplerInfo.mipLodBias = mipmapMode;
                               ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:39:32: note: samplerInfo.mipLodBias is overwritten
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:23:28: style: C-style pointer casting [cstyleCast]
        m_GraphicsDevice = (GraphicsDeviceVk *)graphicsDevice;
                           ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:253:39: style: Variable 'queueFamilyIndices' is assigned a value that is never used. [unreadVariable]
        uint32_t queueFamilyIndices[] = {m_GraphicsDevice->m_GraphicsQueueFamilyIndex, m_GraphicsDevice->m_PresentQueueFamilyIndex};
                                      ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:256:24: style: Variable 'imageCount' is assigned a value that is never used. [unreadVariable]
            imageCount = m_SurfaceCapabilities.maxImageCount;
                       ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:291:35: style: Variable 'validDepthFormat' is assigned a value that is never used. [unreadVariable]
        VkBool32 validDepthFormat = GetSupportedDepthFormat(m_GraphicsDevice->m_PhysicalDevice, &m_DepthFormat);
                                  ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:76:25: style: Redundant initialization for 'aspectFlags'. The initialized value is overwritten before it is read. [redundantInitialization]
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:73:43: note: aspectFlags is initialized
        VkImageAspectFlagBits aspectFlags = {};
                                          ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:76:25: note: aspectFlags is overwritten
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
src/Nexus/src/Platform/Vulkan/Vk.cpp:474:21: style: Consider using std::any_of, std::all_of, std::none_of, or std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            isDepth = true;
                    ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

