Source/Demo/Demos/ClearScreenDemo.hpp:13:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/TimingDemo.hpp:15:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/HelloTriangle.hpp:13:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/HelloTriangleIndexed.hpp:13:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Texturing.hpp:14:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/UniformBufferDemo.hpp:18:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Demo3D.hpp:27:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/CameraDemo.hpp:29:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Lighting.hpp:28:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Models.hpp:28:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/AudioDemo.hpp:13:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/PythonDemo.hpp:15:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/BatchingDemo.hpp:17:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/FramebufferDemo.hpp:13:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/InstancingDemo.hpp:23:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/MipmapDemo.hpp:15:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/ClippingAndTriangulationDemo.hpp:15:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Splines.hpp:17:13: performance: Variable 'm_CommandList' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_CommandList = m_GraphicsDevice->CreateCommandList();
            ^
Source/Demo/Demos/Demo.hpp:31:28: style:inconclusive: Technically the member function 'Demos::Demo::GetName' can be const. [functionConst]
        const std::string &GetName() { return m_Name; }
                           ^
Source/Demo/Demos/BatchingDemo.hpp:18:13: warning: Class 'BatchingDemo' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/Demos/BatchingDemo.hpp:18:13: warning: Class 'BatchingDemo' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/Demos/ClippingAndTriangulationDemo.hpp:16:13: warning: Class 'ClippingAndTriangulationDemo' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/Demos/ClippingAndTriangulationDemo.hpp:16:13: warning: Class 'ClippingAndTriangulationDemo' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/Demos/Splines.hpp:18:13: warning: Class 'Splines' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/Demos/Splines.hpp:18:13: warning: Class 'Splines' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
            m_BatchRenderer = new Nexus::Graphics::BatchRenderer(m_GraphicsDevice, {m_GraphicsDevice->GetPrimaryWindow()->GetSwapchain()});
            ^
Source/Demo/main.cpp:39:5: style: Class 'DemoApplication' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DemoApplication(const Nexus::ApplicationSpecification &spec)
    ^
Source/Demo/main.cpp:193:28: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
                    auto n = m_GraphicsDevice->GetAPIName();
                           ^
Source/Editor/UI/Dialogs/NewProjectDialog.cpp:58:56: style: Variable 'fullpath' is assigned a value that is never used. [unreadVariable]
                        std::filesystem::path fullpath = directory + std::string("\\") + m_Name + extension;
                                                       ^
Source/Editor/UI/Panel.hpp:17:14: style:inconclusive: Technically the member function 'Editor::Panel::IsEnabled' can be const. [functionConst]
        bool IsEnabled() { return m_Enabled; }
             ^
Source/Editor/UI/Layout.hpp:16:9: style: Class 'Layout' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Layout(Nexus::Application *app);
        ^
Source/Editor/UI/Layout.cpp:22:9: performance: Variable 'm_ImGuiRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_ImGuiRenderer = std::make_unique<Nexus::ImGuiUtils::ImGuiGraphicsRenderer>(app);
        ^
Source/Editor/UI/Layout.hpp:18:14: performance:inconclusive: Technically the member function 'Editor::Layout::LoadProject' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void LoadProject(const std::string &path);
             ^
Source/Editor/UI/Layout.cpp:51:18: note: Technically the member function 'Editor::Layout::LoadProject' can be static (but you may consider moving to unnamed namespace).
    void Layout::LoadProject(const std::string &path)
                 ^
Source/Editor/UI/Layout.hpp:18:14: note: Technically the member function 'Editor::Layout::LoadProject' can be static (but you may consider moving to unnamed namespace).
        void LoadProject(const std::string &path);
             ^
Source/Editor/UI/Layout.hpp:20:14: performance:inconclusive: Technically the member function 'Editor::Layout::SaveLayout' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SaveLayout(const std::string &path) const;
             ^
Source/Editor/UI/Layout.cpp:57:18: note: Technically the member function 'Editor::Layout::SaveLayout' can be static (but you may consider moving to unnamed namespace).
    void Layout::SaveLayout(const std::string &path) const
                 ^
Source/Editor/UI/Layout.hpp:20:14: note: Technically the member function 'Editor::Layout::SaveLayout' can be static (but you may consider moving to unnamed namespace).
        void SaveLayout(const std::string &path) const;
             ^
Source/Editor/UI/Layout.hpp:21:14: performance:inconclusive: Technically the member function 'Editor::Layout::LoadLayout' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        bool LoadLayout(const std::string &path);
             ^
Source/Editor/UI/Layout.cpp:62:18: note: Technically the member function 'Editor::Layout::LoadLayout' can be static (but you may consider moving to unnamed namespace).
    bool Layout::LoadLayout(const std::string &path)
                 ^
Source/Editor/UI/Layout.hpp:21:14: note: Technically the member function 'Editor::Layout::LoadLayout' can be static (but you may consider moving to unnamed namespace).
        bool LoadLayout(const std::string &path);
             ^
Source/Editor/UI/Layout.hpp:29:14: performance:inconclusive: Technically the member function 'Editor::Layout::ApplyDarkTheme' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void ApplyDarkTheme();
             ^
Source/Editor/UI/Layout.cpp:103:18: note: Technically the member function 'Editor::Layout::ApplyDarkTheme' can be static (but you may consider moving to unnamed namespace).
    void Layout::ApplyDarkTheme()
                 ^
Source/Editor/UI/Layout.hpp:29:14: note: Technically the member function 'Editor::Layout::ApplyDarkTheme' can be static (but you may consider moving to unnamed namespace).
        void ApplyDarkTheme();
             ^
Source/Editor/UI/SceneHierarchy.hpp:14:14: performance:inconclusive: Technically the member function 'Editor::SceneHierarchy::RenderControls' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void RenderControls();
             ^
Source/Editor/UI/SceneHierarchy.cpp:27:26: note: Technically the member function 'Editor::SceneHierarchy::RenderControls' can be static (but you may consider moving to unnamed namespace).
    void SceneHierarchy::RenderControls()
                         ^
Source/Editor/UI/SceneHierarchy.hpp:14:14: note: Technically the member function 'Editor::SceneHierarchy::RenderControls' can be static (but you may consider moving to unnamed namespace).
        void RenderControls();
             ^
Source/NexusEngine/Nexus/Application.hpp:30:5: style: The class 'Clock' does not have a constructor although it has private member variables. [noConstructor]
    class Clock
    ^
Source/NexusEngine/Nexus/Application.cpp:267:18: warning: Member variable 'Application::m_Clock' is not initialized in the constructor. [uninitMemberVar]
    Application::Application(const ApplicationSpecification &spec)
                 ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:24:13: performance: Variable 'm_Target' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_Target = swapchain;
            ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:30:13: performance: Variable 'm_Target' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_Target = framebuffer;
            ^
Source/NexusEngine/Nexus/Graphics/Pipeline.hpp:52:13: performance: Variable 'm_Description' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_Description = description;
            ^
Source/NexusEngine/Nexus/Application.cpp:269:9: performance: Variable 'm_Specification' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Specification = spec;
        ^
Source/NexusEngine/Nexus/Point.hpp:81:14: style:inconclusive: Technically the member function 'Nexus::Point3D::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y, T *z)
             ^
Source/NexusEngine/Nexus/Graphics/GPUBuffer.hpp:55:34: style:inconclusive: Technically the member function 'Nexus::Graphics::VertexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
Source/NexusEngine/Nexus/Graphics/GPUBuffer.hpp:79:34: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
Source/NexusEngine/Nexus/Graphics/GPUBuffer.hpp:81:27: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetFormat' can be const. [functionConst]
        IndexBufferFormat GetFormat() { return m_Format; }
                          ^
Source/NexusEngine/Nexus/Graphics/GPUBuffer.hpp:108:34: style:inconclusive: Technically the member function 'Nexus::Graphics::UniformBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
Source/NexusEngine/Nexus/Graphics/Framebuffer.hpp:91:13: style:inconclusive: Technically the member function 'Nexus::Graphics::Framebuffer::GetColorTextureCount' can be const. [functionConst]
        int GetColorTextureCount() { return m_Specification.ColorAttachmentSpecification.Attachments.size(); }
            ^
Source/NexusEngine/Nexus/Graphics/Swapchain.hpp:31:39: style:inconclusive: Technically the member function 'Nexus::Graphics::Swapchain::GetSpecification' can be const. [functionConst]
        const SwapchainSpecification &GetSpecification()
                                      ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:45:26: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::GetType' can be const. [functionConst]
        RenderTargetType GetType()
                         ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:105:14: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::IsValid' can be const. [functionConst]
        bool IsValid()
             ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:110:24: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::operator==' can be const. [functionConst]
        constexpr bool operator==(const RenderTarget &other)
                       ^
Source/NexusEngine/Nexus/Graphics/GraphicsDevice.hpp:72:21: style:inconclusive: Technically the member function 'Nexus::Graphics::GraphicsDevice::GetGraphicsAPI' can be const. [functionConst]
        GraphicsAPI GetGraphicsAPI() { return this->m_API; }
                    ^
Source/NexusEngine/Nexus/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < uint32_t >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
Source/NexusEngine/Nexus/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < int >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
Source/NexusEngine/Nexus/Point.hpp:66:9: style: Struct 'Point3D' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point3D(T x)
        ^
Source/NexusEngine/Nexus/Graphics/Framebuffer.hpp:22:9: style: Struct 'FramebufferTextureSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferTextureSpecification(PixelFormat format)
        ^
Source/NexusEngine/Nexus/Graphics/Framebuffer.hpp:37:9: style: Struct 'FramebufferColorAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferColorAttachmentSpecification(std::initializer_list<FramebufferTextureSpecification> attachments)
        ^
Source/NexusEngine/Nexus/Graphics/Framebuffer.hpp:52:9: style: Struct 'FramebufferDepthAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferDepthAttachmentSpecification(PixelFormat format)
        ^
Source/NexusEngine/Nexus/Graphics/Scissor.hpp:16:9: style: Struct 'Scissor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Scissor(const Rectangle<float> &rect)
        ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:22:9: style: Class 'RenderTarget' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        RenderTarget(Swapchain *swapchain)
        ^
Source/NexusEngine/Nexus/Graphics/RenderTarget.hpp:28:9: style: Class 'RenderTarget' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        RenderTarget(Ref<Framebuffer> framebuffer)
        ^
Source/NexusEngine/Nexus/Point.hpp:20:9: style: Struct 'Point2D < uint32_t >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
Source/NexusEngine/Nexus/Point.hpp:20:9: style: Struct 'Point2D < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
Source/NexusEngine/Nexus/Application.cpp:624:32: style: Variable 'indexToRemove' is assigned a value that is never used. [unreadVariable]
        uint32_t indexToRemove = 0;
                               ^
Source/NexusEngine/Nexus/AssetManager.hpp:18:9: style: Class 'AssetManager' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AssetManager(Graphics::GraphicsDevice *graphicsDevice) : m_GraphicsDevice(graphicsDevice) {}
        ^
Source/NexusEngine/Nexus/FileSystem/FileDialogs.cpp:10:52: performance: Function parameter 'filters' should be passed by const reference. [passedByValue]
    const char *OpenFile(std::vector<const char *> filters)
                                                   ^
Source/NexusEngine/Nexus/FileSystem/FileDialogs.cpp:22:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
Source/NexusEngine/Nexus/FileSystem/FileDialogs.cpp:32:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
Source/NexusEngine/Nexus/Graphics/Font.hpp:92:46: style:inconclusive: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const. [functionConst]
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
Source/NexusEngine/Nexus/Graphics/Font.cpp:140:48: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
    Nexus::Ref<Nexus::Graphics::Texture> Font::GetTexture()
                                               ^
Source/NexusEngine/Nexus/Graphics/Font.hpp:92:46: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:12:27: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const. [functionConst]
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.cpp:32:39: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
    Ref<VertexBuffer> FullscreenQuad::GetVertexBuffer()
                                      ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:12:27: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:13:26: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const. [functionConst]
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.cpp:37:38: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
    Ref<IndexBuffer> FullscreenQuad::GetIndexBuffer()
                                     ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:13:26: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:15:45: performance:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.cpp:42:57: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
    Nexus::Graphics::VertexBufferLayout FullscreenQuad::GetVertexBufferLayout()
                                                        ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:15:45: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
Source/NexusEngine/Nexus/Graphics/FullscreenQuad.hpp:10:9: style: Class 'FullscreenQuad' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FullscreenQuad(GraphicsDevice *device);
        ^
Source/NexusEngine/Nexus/Graphics/GraphicsDevice.cpp:20:9: performance: Variable 'm_API' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_API = createInfo.API;
        ^
Source/NexusEngine/Nexus/Graphics/GraphicsDevice.cpp:52:24: style: Variable 'totalTime' is assigned a value that is never used. [unreadVariable]
        auto totalTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
                       ^
Source/NexusEngine/Nexus/Graphics/GraphicsDevice.cpp:37:21: style: Unused variable: errorMessage [unusedVariable]
        std::string errorMessage;
                    ^
Source/NexusEngine/Nexus/Graphics/MipmapGenerator.hpp:27:9: style: Class 'MipmapGenerator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        MipmapGenerator(GraphicsDevice *device);
        ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:76:50: style:inconclusive: Boolean expression 'language==ShaderLanguage::GLSL' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.hpp:74:27: performance:inconclusive: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:291:40: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
    CompilationResult ShaderGenerator::Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources)
                                       ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.hpp:74:27: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:76:50: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:321:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:321:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:333:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:333:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:345:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:345:39: note: Shadow variable
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:369:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:369:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:385:31: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            shaderc::Compiler compiler;
                              ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:385:31: note: Shadow variable
            shaderc::Compiler compiler;
                              ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:386:18: style: Local variable 'shaderType' shadows outer variable [shadowVariable]
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:301:14: note: Shadowed declaration
        auto shaderType = GetTypeOfShader(options.Stage);
             ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:386:18: note: Shadow variable
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:387:40: style: Local variable 'result' shadows outer variable [shadowVariable]
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:302:36: note: Shadowed declaration
        shaderc::CompilationResult result = compiler.CompileGlslToSpv(source, shaderType, options.ShaderName.c_str());
                                   ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:387:40: note: Shadow variable
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:389:35: style: Local variable 'spirv_binary' shadows outer variable [shadowVariable]
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:310:31: note: Shadowed declaration
        std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                              ^
Source/NexusEngine/Nexus/Graphics/ShaderGenerator.cpp:389:35: note: Shadow variable
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.hpp:37:33: style:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::GetPipeline' can be const. [functionConst]
        Ref<Graphics::Pipeline> GetPipeline() { return m_Pipeline; }
                                ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.hpp:46:14: performance:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void UpdateMonitors();
             ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:719:33: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
    void ImGuiGraphicsRenderer::UpdateMonitors()
                                ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.hpp:46:14: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
        void UpdateMonitors();
             ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.hpp:27:9: style: Class 'ImGuiGraphicsRenderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ImGuiGraphicsRenderer(Nexus::Application *app);
        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:205:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:217:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:230:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:243:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:256:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:269:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:283:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:296:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:308:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:321:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:336:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:431:45: style: C-style pointer casting [cstyleCast]
                    ImGuiWindowInfo *info = (ImGuiWindowInfo *)platform_io.Viewports[i]->PlatformUserData;
                                            ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:599:33: style: C-style pointer casting [cstyleCast]
        ImGuiWindowInfo *info = (ImGuiWindowInfo *)drawData->OwnerViewport->PlatformUserData;
                                ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:539:56: style: Variable 'layout' is assigned a value that is never used. [unreadVariable]
            Nexus::Graphics::VertexBufferLayout layout =
                                                       ^
Source/NexusEngine/Nexus/ImGui/ImGuiGraphicsRenderer.cpp:617:27: style: Variable 'vp' is assigned a value that is never used. [unreadVariable]
        ImGuiViewport *vp = drawData->OwnerViewport;
                          ^
Source/NexusEngine/Nexus/Input/Gamepad.hpp:164:24: style:inconclusive: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const. [functionConst]
        const uint32_t GetControllerIndex();
                       ^
Source/NexusEngine/Nexus/Input/Gamepad.cpp:200:29: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
    const uint32_t Gamepad::GetControllerIndex()
                            ^
Source/NexusEngine/Nexus/Input/Gamepad.hpp:164:24: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
        const uint32_t GetControllerIndex();
                       ^
Source/NexusEngine/Nexus/Input/Gamepad.hpp:93:9: style: Class 'Gamepad' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Gamepad(uint32_t index);
        ^
Source/NexusEngine/Nexus/Input/Mouse.hpp:37:5: style: The class 'Mouse' does not have a constructor although it has private member variables. [noConstructor]
    class Mouse
    ^
Source/NexusEngine/Nexus/Input/InputState.hpp:19:5: style: The class 'InputState' does not have a constructor although it has private member variables. [noConstructor]
    class InputState
    ^
Source/NexusEngine/Nexus/Input/Input.hpp:176:14: performance:inconclusive: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void CacheInput();
             ^
Source/NexusEngine/Nexus/Input/Input.cpp:234:17: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
    void Input::CacheInput()
                ^
Source/NexusEngine/Nexus/Input/Input.hpp:176:14: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
        void CacheInput();
             ^
Source/NexusEngine/Nexus/Input/Keyboard.hpp:133:14: style:inconclusive: Technically the member function 'Nexus::Keyboard::CacheInput' can be const. [functionConst]
        void CacheInput();
             ^
Source/NexusEngine/Nexus/Input/Keyboard.cpp:5:20: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
    void Keyboard::CacheInput()
                   ^
Source/NexusEngine/Nexus/Input/Keyboard.hpp:133:14: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
        void CacheInput();
             ^
Source/NexusEngine/Nexus/Logging/Log.hpp:66:28: style: Unused private function: 'Logger::GetTime' [unusedPrivateFunction]
        static std::string GetTime();
                           ^
Source/NexusEngine/Nexus/Logging/Log.hpp:61:40: style:inconclusive: Technically the member function 'Nexus::Logger::GetLogs' can be const. [functionConst]
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
Source/NexusEngine/Nexus/Logging/Log.cpp:64:44: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
    const std::vector<Nexus::Log> &Logger::GetLogs()
                                           ^
Source/NexusEngine/Nexus/Logging/Log.hpp:61:40: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
Source/NexusEngine/Nexus/Renderer.hpp:17:14: performance:inconclusive: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void End();
             ^
Source/NexusEngine/Nexus/Renderer.cpp:10:20: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
    void Renderer::End()
                   ^
Source/NexusEngine/Nexus/Renderer.hpp:17:14: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
        void End();
             ^
Source/NexusEngine/Nexus/Renderer.hpp:28:9: style: Class 'Renderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Renderer(Graphics::GraphicsDevice *device);
        ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.hpp:106:50: style:inconclusive: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list. [initializerList]
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.cpp:514:53: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        : m_Device(device), m_RenderTarget(target), m_CommandList(m_Device->CreateCommandList())
                                                    ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.hpp:106:50: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.hpp:100:14: style:inconclusive: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const. [functionConst]
        void EnsureStarted();
             ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.cpp:1151:25: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
    void BatchRenderer::EnsureStarted()
                        ^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.hpp:100:14: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
        void EnsureStarted();
             ^
Source/NexusEngine/Nexus/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < float >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
Source/NexusEngine/Nexus/Point.hpp:20:9: style: Struct 'Point2D < float >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
Source/NexusEngine/Nexus/Runtime/Entity.hpp:21:14: performance:inconclusive: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        bool Deserialize(YAML::Node &data);
             ^
Source/NexusEngine/Nexus/Runtime/Entity.cpp:38:18: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
    bool Entity::Deserialize(YAML::Node &data)
                 ^
Source/NexusEngine/Nexus/Runtime/Entity.hpp:21:14: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
        bool Deserialize(YAML::Node &data);
             ^
Source/NexusEngine/Nexus/Runtime/Project.cpp:18:9: performance: Variable 'm_SceneDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SceneDirectory = "\\Scenes";
        ^
Source/NexusEngine/Nexus/Runtime/Project.cpp:19:9: performance: Variable 'm_AssetsDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_AssetsDirectory = "\\Assets";
        ^
Source/NexusEngine/Nexus/Runtime/Project.hpp:38:14: style:inconclusive: Technically the member function 'Nexus::Project::WriteProjectFile' can be const. [functionConst]
        void WriteProjectFile();
             ^
Source/NexusEngine/Nexus/Runtime/Project.cpp:98:19: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
    void Project::WriteProjectFile()
                  ^
Source/NexusEngine/Nexus/Runtime/Project.hpp:38:14: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
        void WriteProjectFile();
             ^
Source/NexusEngine/Nexus/Runtime/Scene.hpp:24:14: style:inconclusive: Technically the member function 'Nexus::Scene::Serialize' can be const. [functionConst]
        void Serialize(const std::string &filepath);
             ^
Source/NexusEngine/Nexus/Runtime/Scene.cpp:119:17: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
    void Scene::Serialize(const std::string &filepath)
                ^
Source/NexusEngine/Nexus/Runtime/Scene.hpp:24:14: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
        void Serialize(const std::string &filepath);
             ^
Source/NexusEngine/Nexus/UI/Canvas.cpp:9:9: performance: Variable 'm_BatchRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_BatchRenderer = std::make_unique<Nexus::Graphics::BatchRenderer>(device, Nexus::Graphics::RenderTarget{swapchain});
        ^
Source/NexusEngine/Nexus/Vertex.hpp:46:9: style: Struct 'VertexBufferLayout' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexBufferLayout(std::initializer_list<VertexBufferElement> elements)
        ^
Source/NexusEngine/Nexus/Vertex.hpp:111:9: style: Struct 'VertexPosition' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexPosition(const glm::vec3 &position)
        ^
Source/NexusEngine/Nexus/Window.hpp:80:14: style:inconclusive: Technically the member function 'Nexus::Window::IsClosing' can be const. [functionConst]
        bool IsClosing();
             ^
Source/NexusEngine/Nexus/Window.cpp:68:18: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
    bool Window::IsClosing()
                 ^
Source/NexusEngine/Nexus/Window.hpp:80:14: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
        bool IsClosing();
             ^
Source/NexusEngine/Nexus/Window.hpp:100:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetIsMouseVisible(bool visible);
             ^
Source/NexusEngine/Nexus/Window.cpp:122:18: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
    void Window::SetIsMouseVisible(bool visible)
                 ^
Source/NexusEngine/Nexus/Window.hpp:100:14: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
        void SetIsMouseVisible(bool visible);
             ^
Source/NexusEngine/Nexus/Window.hpp:104:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetCursor(Cursor cursor);
             ^
Source/NexusEngine/Nexus/Window.cpp:135:18: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
    void Window::SetCursor(Cursor cursor)
                 ^
Source/NexusEngine/Nexus/Window.hpp:104:14: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
        void SetCursor(Cursor cursor);
             ^
Source/NexusEngine/Nexus/Window.hpp:108:27: style:inconclusive: Technically the member function 'Nexus::Window::GetInput' can be const. [functionConst]
        const InputState *GetInput();
                          ^
Source/NexusEngine/Nexus/Window.cpp:182:31: note: Technically the member function 'Nexus::Window::GetInput' can be const.
    const InputState *Window::GetInput()
                              ^
Source/NexusEngine/Nexus/Window.hpp:108:27: note: Technically the member function 'Nexus::Window::GetInput' can be const.
        const InputState *GetInput();
                          ^
Source/NexusEngine/Nexus/Window.hpp:153:18: style:inconclusive: Technically the member function 'Nexus::Window::GetID' can be const. [functionConst]
        uint32_t GetID();
                 ^
Source/NexusEngine/Nexus/Window.cpp:298:22: note: Technically the member function 'Nexus::Window::GetID' can be const.
    uint32_t Window::GetID()
                     ^
Source/NexusEngine/Nexus/Window.hpp:153:18: note: Technically the member function 'Nexus::Window::GetID' can be const.
        uint32_t GetID();
                 ^
Source/NexusEngine/Nexus/Window.hpp:157:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
Source/NexusEngine/Nexus/Window.cpp:308:18: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
    void Window::SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect)
                 ^
Source/NexusEngine/Nexus/Window.hpp:157:14: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
Source/NexusEngine/Nexus/Window.hpp:158:14: performance:inconclusive: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StartTextInput();
             ^
Source/NexusEngine/Nexus/Window.cpp:318:18: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StartTextInput()
                 ^
Source/NexusEngine/Nexus/Window.hpp:158:14: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
        void StartTextInput();
             ^
Source/NexusEngine/Nexus/Window.hpp:159:14: performance:inconclusive: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StopTextInput();
             ^
Source/NexusEngine/Nexus/Window.cpp:322:18: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StopTextInput()
                 ^
Source/NexusEngine/Nexus/Window.hpp:159:14: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
        void StopTextInput();
             ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.hpp:17:9: style: Class 'CommandListD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListD3D12(GraphicsDeviceD3D12 *device);
        ^
Source/NexusEngine/Platform/D3D12/TimingQueryD3D12.hpp:14:9: style: Class 'TimingQueryD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryD3D12(GraphicsDeviceD3D12 *device);
        ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:175:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)target.GetData<Swapchain *>();
                                  ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:233:31: style: C-style pointer casting [cstyleCast]
        auto swapchainD3D12 = (SwapchainD3D12 *)target;
                              ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:428:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)m_CurrentRenderTarget.GetData<Swapchain *>();
                                  ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:71:54: style:inconclusive: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'. [funcArgNamesDifferent]
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.hpp:25:48: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
        virtual void SetPipeline(Ref<Pipeline> ipeline) override;
                                               ^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:71:54: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
Source/NexusEngine/Platform/D3D12/FramebufferD3D12.cpp:61:26: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        auto d3d12Device = m_Device->GetDevice();
                         ^
Source/NexusEngine/Platform/D3D12/SamplerD3D12.hpp:13:9: style: Class 'SamplerD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerD3D12(const SamplerSpecification &spec);
        ^
Source/NexusEngine/Platform/D3D12/GraphicsDeviceD3D12.cpp:22:37: style: Variable 'experimentalFeatures' is assigned a value that is never used. [unreadVariable]
        UUID experimentalFeatures[] = {D3D12ExperimentalShaderModels};
                                    ^
Source/NexusEngine/Platform/D3D12/PipelineD3D12.hpp:35:29: style:inconclusive: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list. [initializerList]
        PipelineDescription m_Description;
                            ^
Source/NexusEngine/Platform/D3D12/PipelineD3D12.cpp:14:52: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        : Pipeline(description), m_Device(device), m_Description(description)
                                                   ^
Source/NexusEngine/Platform/D3D12/PipelineD3D12.hpp:35:29: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        PipelineDescription m_Description;
                            ^
Source/NexusEngine/Platform/D3D12/PipelineD3D12.cpp:161:30: style: C-style pointer casting [cstyleCast]
            auto swapchain = (SwapchainD3D12 *)m_Description.Target.GetData<Swapchain *>();
                             ^
Source/NexusEngine/Platform/D3D12/ResourceSetD3D12.cpp:142:18: style: Local variable 'd3d12Device' shadows outer variable [shadowVariable]
            auto d3d12Device = m_Device->GetDevice();
                 ^
Source/NexusEngine/Platform/D3D12/ResourceSetD3D12.cpp:114:20: note: Shadowed declaration
        const auto d3d12Device = m_Device->GetDevice();
                   ^
Source/NexusEngine/Platform/D3D12/ResourceSetD3D12.cpp:142:18: note: Shadow variable
            auto d3d12Device = m_Device->GetDevice();
                 ^
Source/NexusEngine/Platform/D3D12/ResourceSetD3D12.cpp:20:38: style: Variable 'constantBufferCount' is assigned a value that is never used. [unreadVariable]
        uint32_t constantBufferCount = spec.UniformBuffers.size();
                                     ^
Source/NexusEngine/Platform/D3D12/SamplerD3D12.cpp:12:9: performance: Variable 'm_SamplerFilter' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SamplerFilter = GetD3D12Filter(spec.SampleFilter);
        ^
Source/NexusEngine/Platform/D3D12/ShaderModuleD3D12.cpp:67:26: style: Variable 'hr' is assigned a value that is never used. [unreadVariable]
        const HRESULT hr = compiler->Compile(
                         ^
Source/NexusEngine/Platform/D3D12/SwapchainD3D12.cpp:11:20: style: C-style pointer casting [cstyleCast]
        m_Device = (GraphicsDeviceD3D12 *)device;
                   ^
Source/NexusEngine/Platform/D3D12/TimingQueryD3D12.cpp:10:37: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        ID3D12Device10 *d3d12Device = m_Device->GetDevice();
                                    ^
Source/NexusEngine/Platform/OpenAL/AudioSourceOpenAL.hpp:17:9: style: Class 'AudioSourceOpenAL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AudioSourceOpenAL(Ref<AudioBuffer> buffer);
        ^
Source/NexusEngine/Platform/OpenAL/AudioDeviceOpenAL.cpp:89:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
Source/NexusEngine/Platform/OpenAL/AudioDeviceOpenAL.cpp:105:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
Source/NexusEngine/Platform/OpenAL/AudioSourceOpenAL.cpp:11:9: performance: Variable 'm_Buffer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Buffer = buffer;
        ^
Source/NexusEngine/Platform/OpenGL/PipelineOpenGL.hpp:13:9: style: Class 'PipelineOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        PipelineOpenGL(const PipelineDescription &description);
        ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.hpp:19:9: style: Class 'CommandListOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListOpenGL(GraphicsDevice *device);
        ^
Source/NexusEngine/Platform/OpenGL/TextureOpenGL.hpp:13:9: style: Class 'TextureOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TextureOpenGL(const TextureSpecification &spec);
        ^
Source/NexusEngine/Platform/OpenGL/ResourceSetOpenGL.hpp:18:9: style: Class 'ResourceSetOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ResourceSetOpenGL(const ResourceSetSpecification &spec);
        ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.cpp:100:35: style: C-style pointer casting [cstyleCast]
            auto graphicsDevice = (GraphicsDeviceOpenGL *)commandListGL->GetGraphicsDevice();
                                  ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.cpp:338:35: style: C-style pointer casting [cstyleCast]
            auto graphicsDevice = (GraphicsDeviceOpenGL *)commandListGL->GetGraphicsDevice();
                                  ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.cpp:360:35: style: C-style pointer casting [cstyleCast]
            auto graphicsDevice = (GraphicsDeviceOpenGL *)commandListGL->GetGraphicsDevice();
                                  ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.cpp:377:35: style: C-style pointer casting [cstyleCast]
            auto graphicsDevice = (GraphicsDeviceOpenGL *)commandListGL->GetGraphicsDevice();
                                  ^
Source/NexusEngine/Platform/OpenGL/CommandListOpenGL.cpp:465:44: style: C-style pointer casting [cstyleCast]
            SwapchainOpenGL *swapchainGL = (SwapchainOpenGL *)resolveToSwapchainCommand.Target;
                                           ^
Source/NexusEngine/Platform/OpenGL/SamplerOpenGL.hpp:12:9: style: Class 'SamplerOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerOpenGL(const SamplerSpecification &spec);
        ^
Source/NexusEngine/Platform/OpenGL/GraphicsDeviceOpenGL.cpp:158:28: style: C-style pointer casting [cstyleCast]
        auto glSwapchain = (SwapchainOpenGL *)swapchain;
                           ^
Source/NexusEngine/Platform/OpenGL/GraphicsDeviceOpenGL.cpp:168:15: style: Variable 'commands' can be declared with const [constVariable]
        auto &commands = commandListGL->GetRenderCommands();
              ^
Source/NexusEngine/Platform/Vulkan/CommandListVk.hpp:14:9: style: Class 'CommandListVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListVk(GraphicsDeviceVk *graphicsDevice);
        ^
Source/NexusEngine/Platform/Vulkan/TimingQueryVk.hpp:14:9: style: Class 'TimingQueryVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryVk(GraphicsDeviceVk *device);
        ^
Source/NexusEngine/Platform/Vulkan/CommandListVk.cpp:300:36: style: C-style pointer casting [cstyleCast]
            auto vulkanSwapchain = (SwapchainVk *)swapchain;
                                   ^
Source/NexusEngine/Platform/Vulkan/CommandListVk.cpp:445:28: style: C-style pointer casting [cstyleCast]
        auto swapchainVk = (SwapchainVk *)target;
                           ^
Source/NexusEngine/Platform/Vulkan/FramebufferVk.cpp:220:38: error: Using object that points to local variable 'depthReference' that is out of scope. [invalidLifetime]
        renderPassInfo.pSubpasses = &subpass;
                                     ^
Source/NexusEngine/Platform/Vulkan/FramebufferVk.cpp:202:47: note: Address of variable taken here.
            subpass.pDepthStencilAttachment = &depthReference;
                                              ^
Source/NexusEngine/Platform/Vulkan/FramebufferVk.cpp:199:35: note: Variable created here.
            VkAttachmentReference depthReference = {};
                                  ^
Source/NexusEngine/Platform/Vulkan/FramebufferVk.cpp:220:38: note: Using object that points to local variable 'depthReference' that is out of scope.
        renderPassInfo.pSubpasses = &subpass;
                                     ^
Source/NexusEngine/Platform/Vulkan/FramebufferVk.cpp:113:25: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            attachments.push_back(texture->GetImageView());
                        ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:37:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)window->GetSwapchain();
                                 ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:187:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:382:38: style: C-style pointer casting [cstyleCast]
            SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                     ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:470:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:710:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:707:25: note: result is initialized
        VkResult result = vkEnumerateInstanceExtensionProperties(nullptr, &count, nullptr);
                        ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:710:16: note: result is overwritten
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:740:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:737:25: note: result is initialized
        VkResult result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, nullptr);
                        ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:740:16: note: result is overwritten
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:720:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:750:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:34:31: style: Variable 'deviceExtensions' is assigned a value that is never used. [unreadVariable]
        auto deviceExtensions = GetSupportedDeviceExtensions();
                              ^
Source/NexusEngine/Platform/Vulkan/PipelineVk.cpp:156:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
Source/NexusEngine/Platform/Vulkan/PipelineVk.cpp:251:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
Source/NexusEngine/Platform/Vulkan/PipelineVk.cpp:19:21: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            layouts.push_back(layout.second);
                    ^
Source/NexusEngine/Platform/Vulkan/ResourceSetVk.cpp:30:44: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[textureBinding.Set] = {};
                                           ^
Source/NexusEngine/Platform/Vulkan/ResourceSetVk.cpp:36:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
Source/NexusEngine/Platform/Vulkan/ResourceSetVk.cpp:55:50: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[uniformBufferBinding.Set] = {};
                                                 ^
Source/NexusEngine/Platform/Vulkan/ResourceSetVk.cpp:61:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
Source/NexusEngine/Platform/Vulkan/SamplerVk.cpp:39:32: style: Variable 'samplerInfo.mipLodBias' is reassigned a value before the old one has been used. [redundantAssignment]
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
Source/NexusEngine/Platform/Vulkan/SamplerVk.cpp:38:32: note: samplerInfo.mipLodBias is assigned
        samplerInfo.mipLodBias = mipmapMode;
                               ^
Source/NexusEngine/Platform/Vulkan/SamplerVk.cpp:39:32: note: samplerInfo.mipLodBias is overwritten
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:23:28: style: C-style pointer casting [cstyleCast]
        m_GraphicsDevice = (GraphicsDeviceVk *)graphicsDevice;
                           ^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:253:39: style: Variable 'queueFamilyIndices' is assigned a value that is never used. [unreadVariable]
        uint32_t queueFamilyIndices[] = {m_GraphicsDevice->m_GraphicsQueueFamilyIndex, m_GraphicsDevice->m_PresentQueueFamilyIndex};
                                      ^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:256:24: style: Variable 'imageCount' is assigned a value that is never used. [unreadVariable]
            imageCount = m_SurfaceCapabilities.maxImageCount;
                       ^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:291:35: style: Variable 'validDepthFormat' is assigned a value that is never used. [unreadVariable]
        VkBool32 validDepthFormat = GetSupportedDepthFormat(m_GraphicsDevice->m_PhysicalDevice, &m_DepthFormat);
                                  ^
Source/NexusEngine/Platform/Vulkan/TextureVk.cpp:76:25: style: Redundant initialization for 'aspectFlags'. The initialized value is overwritten before it is read. [redundantInitialization]
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
Source/NexusEngine/Platform/Vulkan/TextureVk.cpp:73:43: note: aspectFlags is initialized
        VkImageAspectFlagBits aspectFlags = {};
                                          ^
Source/NexusEngine/Platform/Vulkan/TextureVk.cpp:76:25: note: aspectFlags is overwritten
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
Source/NexusEngine/Platform/Vulkan/Vk.cpp:474:21: style: Consider using std::any_of, std::all_of, std::none_of, or std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            isDepth = true;
                    ^
Source/Test/main.cpp:26:9: performance: Variable 'm_Texture' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Texture = m_GraphicsDevice->CreateTexture(Nexus::FileSystem::GetFilePathAbsolute("resources/textures/brick.jpg"), false);
        ^
Source/Editor/Editor.hpp:9:1: error: The one definition rule is violated, different classes/structs have the same name 'EditorApplication' [ctuOneDefinitionRuleViolation]
class EditorApplication : public Nexus::Application
^
Source/Test/main.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'EditorApplication'
class EditorApplication : public Nexus::Application
^
Source/Editor/Editor.hpp:9:1: note: The one definition rule is violated, different classes/structs have the same name 'EditorApplication'
class EditorApplication : public Nexus::Application
^
Source/NexusEngine/Nexus/Utils/Utils.cpp:5:0: style: The function 'ColorFromRGBA' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Renderer.cpp:14:0: style: The function 'Create' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenAL/AudioDeviceOpenAL.cpp:98:0: style: The function 'CreateAudioBufferFromMP3File' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/PipelineVk.cpp:199:0: style: The function 'CreatePipelineShaderStageCreateInfo' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Graphics/MeshFactory.cpp:114:0: style: The function 'CreateTriangle' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:695:0: style: The function 'DestroyDebugUtilsMessengerEXT' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.cpp:987:0: style: The function 'DrawCross' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Utils/Utils.cpp:123:0: style: The function 'FindPolygonArea' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/GraphicsDeviceOpenGL.cpp:15:0: style: The function 'GLDebugMessageCallback' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:167:0: style: The function 'GamepadRumble' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:175:0: style: The function 'GamepadRumbleTriggers' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:183:0: style: The function 'GamepadSetLED' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime.cpp:40:0: style: The function 'GetAssetManager' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Canvas.cpp:48:0: style: The function 'GetBackgroundColour' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:130:0: style: The function 'GetBorderColour' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:125:0: style: The function 'GetBorderThickness' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Vertex.cpp:10:0: style: The function 'GetComponentCount' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/GraphicsDeviceD3D12.cpp:101:0: style: The function 'GetContext' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:210:0: style: The function 'GetControls' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Application.cpp:381:0: style: The function 'GetCoreInputState' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:120:0: style: The function 'GetCornerRounding' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/SwapchainD3D12.cpp:58:0: style: The function 'GetCurrentBufferIndex' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:795:0: style: The function 'GetCurrentFrame' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/CommandListVk.cpp:512:0: style: The function 'GetCurrentSemaphore' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/CommandListD3D12.cpp:15:0: style: The function 'GetD3D12IndexBufferFormat' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/TextureOpenGL.cpp:88:0: style: The function 'GetDataFormat' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Gamepad.cpp:170:0: style: The function 'GetDeadzone' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:95:0: style: The function 'GetDepthFormat' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/GraphicsDeviceD3D12.cpp:96:0: style: The function 'GetDeviceName' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/D3D12Utils.cpp:200:0: style: The function 'GetFillMode' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:91:0: style: The function 'GetFontSize' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:100:0: style: The function 'GetForegroundColour' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/ShaderModuleOpenGL.cpp:30:0: style: The function 'GetGLShaderStage' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:133:0: style: The function 'GetGamepadAxisLeft' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:142:0: style: The function 'GetGamepadAxisRight' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:201:0: style: The function 'GetGamepadByIndex' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:151:0: style: The function 'GetGamepadLeftTrigger' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:159:0: style: The function 'GetGamepadRightTrigger' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Button.cpp:110:0: style: The function 'GetHoveredColour' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Vertex.cpp:166:0: style: The function 'GetIndexInArray' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Keyboard.cpp:25:0: style: The function 'GetKeys' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Logging/Log.cpp:64:0: style: The function 'GetLogs' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Graphics/Font.cpp:203:0: style: The function 'GetMaxCharacterSize' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:84:0: style: The function 'GetMouseScrollMovementX' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:96:0: style: The function 'GetMouseScrollMovementY' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:78:0: style: The function 'GetMouseScrollX' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:90:0: style: The function 'GetMouseScrollY' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:135:0: style: The function 'GetPadding' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:196:0: style: The function 'GetPhysicalDevice' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:206:0: style: The function 'GetPresentFamily' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/GL.cpp:816:0: style: The function 'GetSamplerState' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:185:0: style: The function 'GetSemaphore' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:704:0: style: The function 'GetSupportedInstanceExtensions' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/SwapchainVk.cpp:90:0: style: The function 'GetSurfaceFormat' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Button.cpp:105:0: style: The function 'GetText' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/TextureOpenGL.cpp:83:0: style: The function 'GetTextureType' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/GraphicsDeviceD3D12.cpp:194:0: style: The function 'GetUploadCommandList' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/SwapchainD3D12.cpp:34:0: style: The function 'GetVsyncState' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/OpenGL/GL.cpp:831:0: style: The function 'GetWrapMode' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Button.cpp:91:0: style: The function 'HandleMouseClick' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/ResourceSetD3D12.cpp:191:0: style: The function 'HasConstantBuffers' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Gamepad.cpp:180:0: style: The function 'HasTouchpad' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Window.cpp:246:0: style: The function 'Hide' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime.cpp:52:0: style: The function 'Init' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:115:0: style: The function 'IsAutoSized' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:102:0: style: The function 'IsGamepadConnected' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:112:0: style: The function 'IsGamepadKeyHeld' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:12:0: style: The function 'IsLeftMousePressed' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:48:0: style: The function 'IsMiddleMousePressed' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:54:0: style: The function 'IsMiddleMouseReleased' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Utils/Utils.cpp:142:0: style: The function 'IsPointInTriangle' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:30:0: style: The function 'IsRightMousePressed' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:36:0: style: The function 'IsRightMouseReleased' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Vertex.cpp:139:0: style: The function 'IsVertexBuffer' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Application.cpp:344:0: style: The function 'IsWindowFocussed' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Logging/Log.cpp:48:0: style: The function 'LogError' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Logging/Log.cpp:32:0: style: The function 'LogWarning' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Window.cpp:192:0: style: The function 'Maximize' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Window.cpp:197:0: style: The function 'Minimize' is never used. [unusedFunction]

^
Source/Editor/UI/Dialogs/NewProjectDialog.cpp:13:0: style: The function 'OnLoad' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Graphics/ResourceSet.cpp:37:0: style: The function 'RemapToLinearBindings' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Canvas.cpp:87:0: style: The function 'RemoveControl' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Renderer/BatchRenderer.cpp:544:0: style: The function 'Resize' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Window.cpp:202:0: style: The function 'Restore' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime.cpp:19:0: style: The function 'Run' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:52:0: style: The function 'SetBorderColour' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/GraphicsDeviceD3D12.cpp:75:0: style: The function 'SetContext' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Gamepad.cpp:175:0: style: The function 'SetDeadzone' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/UI/Control.cpp:32:0: style: The function 'SetForegroundColour' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/D3D12/FramebufferD3D12.cpp:25:0: style: The function 'SetFramebufferSpecification' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime/Entity.cpp:10:0: style: The function 'SetID' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Window.cpp:44:0: style: The function 'SetResizable' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime.cpp:64:0: style: The function 'Shutdown' is never used. [unusedFunction]

^
Source/NexusEngine/Platform/Vulkan/GraphicsDeviceVk.cpp:320:0: style: The function 'VulkanReportFunc' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:119:0: style: The function 'WasGamepadKeyPressed' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Input.cpp:126:0: style: The function 'WasGamepadKeyReleased' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Input/Mouse.cpp:43:0: style: The function 'WasMiddleMouseClicked' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/FileSystem/FileSystem.cpp:38:0: style: The function 'WriteFile' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime/Scene.cpp:21:0: style: The function 'decode' is never used. [unusedFunction]

^
Source/NexusEngine/Nexus/Runtime/Scene.cpp:12:0: style: The function 'encode' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

