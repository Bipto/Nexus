src/Demo/src/main.cpp:39:5: style: Class 'DemoApplication' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DemoApplication(const Nexus::ApplicationSpecification &spec)
    ^
src/Editor/UI/Dialogs/NewProjectDialog.cpp:58:56: style: Variable 'fullpath' is assigned a value that is never used. [unreadVariable]
                        std::filesystem::path fullpath = directory + std::string("\\") + m_Name + extension;
                                                       ^
src/Editor/UI/Layout.cpp:22:9: performance: Variable 'm_ImGuiRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_ImGuiRenderer = std::make_unique<Nexus::ImGuiUtils::ImGuiGraphicsRenderer>(app);
        ^
src/Editor/UI/Layout.hpp:27:14: performance:inconclusive: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void OpenProject();
             ^
src/Editor/UI/Layout.cpp:193:18: note: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace).
    void Layout::OpenProject()
                 ^
src/Editor/UI/Layout.hpp:27:14: note: Technically the member function 'Editor::Layout::OpenProject' can be static (but you may consider moving to unnamed namespace).
        void OpenProject();
             ^
src/Nexus/external/glad/src/glad.c:971:15: style: Condition 'result==NULL' is always true [knownConditionTrueFalse]
    if(result == NULL) {
              ^
src/Nexus/external/glad/src/glad.c:963:20: note: Assignment 'result=NULL', assigned value is 0
    void* result = NULL;
                   ^
src/Nexus/external/glad/src/glad.c:964:14: note: Assuming condition is false
    if(libGL == NULL) return NULL;
             ^
src/Nexus/external/glad/src/glad.c:971:15: note: Condition 'result==NULL' is always true
    if(result == NULL) {
              ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/hello_wchar_t.c:62:11: error: Uninitialized variable: lWcharBuff [uninitvar]
 mbstowcs(lWcharBuff, tinyfd_version, strlen(tinyfd_version) + 1);
          ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:7233:22: style: Condition '!p' is always false [knownConditionTrueFalse]
                if ( !p || ! strlen( p ) || ! dirExists( p ) )
                     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:304:5: warning: %hx in format string (no. 1) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
    sprintf(aoResultHexRGB, "#%02hx%02hx%02hx", aRGB[0], aRGB[1], aRGB[2]);
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:304:5: warning: %hx in format string (no. 2) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
    sprintf(aoResultHexRGB, "#%02hx%02hx%02hx", aRGB[0], aRGB[1], aRGB[2]);
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:304:5: warning: %hx in format string (no. 3) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
    sprintf(aoResultHexRGB, "#%02hx%02hx%02hx", aRGB[0], aRGB[1], aRGB[2]);
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:7426:17: warning: %hu in format string (no. 1) requires 'unsigned short' but the argument type is 'unsigned char'. [invalidPrintfArgType_uint]
                sprintf(lTmp,"%hu %hu %hu",lDefaultRGB[0],lDefaultRGB[1],lDefaultRGB[2]);
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:7426:17: warning: %hu in format string (no. 2) requires 'unsigned short' but the argument type is 'unsigned char'. [invalidPrintfArgType_uint]
                sprintf(lTmp,"%hu %hu %hu",lDefaultRGB[0],lDefaultRGB[1],lDefaultRGB[2]);
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:7426:17: warning: %hu in format string (no. 3) requires 'unsigned short' but the argument type is 'unsigned char'. [invalidPrintfArgType_uint]
                sprintf(lTmp,"%hu %hu %hu",lDefaultRGB[0],lDefaultRGB[1],lDefaultRGB[2]);
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:6901:6: error: Common realloc mistake: 'lBuff' nulled but not freed upon failure [memleakOnRealloc]
     lBuff = (char *)( realloc( lBuff, (strlen(lBuff)+1) * sizeof(char)));
     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:324:37: warning: Either the condition '!aOldSubStr' is redundant or there is possible null pointer dereference: aOldSubStr. [nullPointerRedundantCheck]
        size_t lOldSubLen = strlen( aOldSubStr ) ;
                                    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:331:14: note: Assuming that condition '!aOldSubStr' is not redundant
        if ( ! aOldSubStr )
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:324:37: note: Null pointer dereference
        size_t lOldSubLen = strlen( aOldSubStr ) ;
                                    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:202:22: style: The scope of the variable 'lTmp' can be reduced. [variableScope]
        char const * lTmp ;
                     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:233:22: style: The scope of the variable 'lTmp' can be reduced. [variableScope]
        char const * lTmp ;
                     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:273:14: style: The scope of the variable 'lColorChannel' can be reduced. [variableScope]
        char lColorChannel[8] ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:386:13: style: The scope of the variable 'i' can be reduced. [variableScope]
        int i;
            ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:388:16: style: The scope of the variable 'lIn' can be reduced. [variableScope]
        FILE * lIn;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3462:14: style: The scope of the variable 'lShellName' can be reduced. [variableScope]
        char lShellName[64] = "*" ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3463:15: style: The scope of the variable 'lArray' can be reduced. [variableScope]
        int * lArray;
              ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3727:9: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
   char lBuff[MAX_PATH_OR_CMD] ;
        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3728:11: style: The scope of the variable 'lIn' can be reduced. [variableScope]
   FILE * lIn ;
          ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3751:14: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
        char lBuff[MAX_PATH_OR_CMD] ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3752:16: style: The scope of the variable 'lIn' can be reduced. [variableScope]
        FILE * lIn ;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3875:14: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
        char lBuff[MAX_PATH_OR_CMD] ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3876:16: style: The scope of the variable 'lIn' can be reduced. [variableScope]
        FILE * lIn ;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3877:7: style: The scope of the variable 'lIntTmp' can be reduced. [variableScope]
  int lIntTmp ;
      ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3916:7: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
 char lBuff[MAX_PATH_OR_CMD] ;
      ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3917:9: style: The scope of the variable 'lIn' can be reduced. [variableScope]
 FILE * lIn ;
        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3918:9: style: The scope of the variable 'lDesktop' can be reduced. [variableScope]
 char * lDesktop;
        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3969:14: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
        char lBuff[MAX_PATH_OR_CMD] ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3970:16: style: The scope of the variable 'lIn' can be reduced. [variableScope]
        FILE * lIn ;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:3996:13: style: The scope of the variable 'i' can be reduced. [variableScope]
        int i;
            ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4025:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4054:14: style: The scope of the variable 'lPythonCommand' can be reduced. [variableScope]
        char lPythonCommand[256];
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4055:14: style: The scope of the variable 'lPythonParams' can be reduced. [variableScope]
        char lPythonParams[128] =
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4075:7: style: The scope of the variable 'lPythonCommand' can be reduced. [variableScope]
 char lPythonCommand[256];
      ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4076:7: style: The scope of the variable 'lPythonParams' can be reduced. [variableScope]
 char lPythonParams[128] =
      ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4096:14: style: The scope of the variable 'lPythonCommand' can be reduced. [variableScope]
        char lPythonCommand[384];
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:4097:14: style: The scope of the variable 'lPythonParams' can be reduced. [variableScope]
        char lPythonParams[256] =
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:6423:14: style: The scope of the variable 'lFullBuffLen' can be reduced. [variableScope]
      size_t lFullBuffLen ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:566:0: information: Skipping configuration 'WC_ERR_INVALID_CHARS;_WIN32' since the value of 'WC_ERR_INVALID_CHARS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 return WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS,
^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:659:0: information: Skipping configuration 'WC_ERR_INVALID_CHARS;_WIN32' since the value of 'WC_ERR_INVALID_CHARS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        lSize = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, aUtf16string, -1, lUtf8string, lSize, NULL, NULL);
^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1726:25: style: Array index 'i' is used before limits check. [arrayIndexThenCheck]
      } while (lPointers[i][0] != L'\0' && i < MAX_MULTIPLE_FILES );
                        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1280:21: style: Condition 'aDefaultInput' is always true [knownConditionTrueFalse]
                if (aDefaultInput && wcslen(aDefaultInput))
                    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1267:14: note: Assuming that condition 'aDefaultInput' is not redundant
        if ( aDefaultInput )
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1280:21: note: Condition 'aDefaultInput' is always true
                if (aDefaultInput && wcslen(aDefaultInput))
                    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:594:5: error: Returning/dereferencing 'lMbcsString' after it is deallocated / released [deallocret]
    return lMbcsString;
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:585:5: note: Returning/dereferencing 'lMbcsString' after it is deallocated / released
    free(lMbcsString);
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:594:5: note: Returning/dereferencing 'lMbcsString' after it is deallocated / released
    return lMbcsString;
    ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:636:2: error: Returning/dereferencing 'lMbcsString' after it is deallocated / released [deallocret]
 return lMbcsString;
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:627:2: note: Returning/dereferencing 'lMbcsString' after it is deallocated / released
 free(lMbcsString);
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:636:2: note: Returning/dereferencing 'lMbcsString' after it is deallocated / released
 return lMbcsString;
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:662:2: error: Returning/dereferencing 'lUtf8string' after it is deallocated / released [deallocret]
 return lUtf8string;
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:653:2: note: Returning/dereferencing 'lUtf8string' after it is deallocated / released
 free(lUtf8string);
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:662:2: note: Returning/dereferencing 'lUtf8string' after it is deallocated / released
 return lUtf8string;
 ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2874:12: style: Redundant initialization for 'hStdin'. The initialized value is overwritten before it is read. [redundantInitialization]
    hStdin = GetStdHandle(STD_INPUT_HANDLE);
           ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2857:16: note: hStdin is initialized
 HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2874:12: note: hStdin is overwritten
    hStdin = GetStdHandle(STD_INPUT_HANDLE);
           ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:470:10: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
    char lBuff[MAX_PATH_OR_CMD];
         ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:471:11: style: The scope of the variable 'lIn' can be reduced. [variableScope]
    FILE* lIn;
          ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:472:17: style: The scope of the variable 'lString' can be reduced. [variableScope]
    char const* lString = "powershell.exe";
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:709:25: style: The scope of the variable 'lTmp' can be reduced. [variableScope]
        wchar_t const * lTmp;
                        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:740:25: style: The scope of the variable 'lTmp' can be reduced. [variableScope]
        wchar_t const * lTmp;
                        ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:767:17: style: The scope of the variable 'lColorChannel' can be reduced. [variableScope]
        wchar_t lColorChannel[8];
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1505:17: style: The scope of the variable 'lDialogString' can be reduced. [variableScope]
        wchar_t lDialogString[MAX_PATH_OR_CMD];
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1507:19: style: The scope of the variable 'p' can be reduced. [variableScope]
        wchar_t * p;
                  ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1606:16: style: The scope of the variable 'lLengths' can be reduced. [variableScope]
        size_t lLengths[MAX_MULTIPLE_FILES];
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1609:17: style: The scope of the variable 'lDialogString' can be reduced. [variableScope]
        wchar_t lDialogString[MAX_PATH_OR_CMD];
                ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1612:16: style: The scope of the variable 'j' can be reduced. [variableScope]
        int i, j;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1613:10: style: The scope of the variable 'lBuffLen' can be reduced. [variableScope]
  size_t lBuffLen;
         ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:1997:10: style: The scope of the variable 'lDefaultInput' can be reduced. [variableScope]
 wchar_t lDefaultInput[MAX_PATH_OR_CMD] = L"";
         ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2268:14: style: The scope of the variable 'lBuff' can be reduced. [variableScope]
        char lBuff[MAX_PATH_OR_CMD] ;
             ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2269:16: style: The scope of the variable 'lIn' can be reduced. [variableScope]
        FILE * lIn ;
               ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2270:22: style: The scope of the variable 'lString' can be reduced. [variableScope]
        char const * lString = "dialog.exe";
                     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:2816:10: style: Variable 'lChar' is assigned a value that is never used. [unreadVariable]
   lChar = (char)_getch();
         ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:804:6: warning: %hx in format string (no. 1) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
     swprintf(aoResultHexRGB, 8, lPrintFormat, aRGB[0], aRGB[1], aRGB[2]);
     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:804:6: warning: %hx in format string (no. 2) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
     swprintf(aoResultHexRGB, 8, lPrintFormat, aRGB[0], aRGB[1], aRGB[2]);
     ^
src/Nexus/external/tinyfiledialogs/tinyfiledialogs/tinyfiledialogs.c:804:6: warning: %hx in format string (no. 3) requires 'unsigned short' but the argument type is 'const unsigned char'. [invalidPrintfArgType_uint]
     swprintf(aoResultHexRGB, 8, lPrintFormat, aRGB[0], aRGB[1], aRGB[2]);
     ^
src/Nexus/src/Nexus-Core/Graphics/Pipeline.hpp:52:13: performance: Variable 'm_Description' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
            m_Description = description;
            ^
src/Nexus/src/Nexus-Core/Application.cpp:268:9: performance: Variable 'm_Specification' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Specification = spec;
        ^
src/Nexus/src/Nexus-Core/Point.hpp:81:14: style:inconclusive: Technically the member function 'Nexus::Point3D::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y, T *z)
             ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:55:34: style:inconclusive: Technically the member function 'Nexus::Graphics::VertexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:79:34: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:81:27: style:inconclusive: Technically the member function 'Nexus::Graphics::IndexBuffer::GetFormat' can be const. [functionConst]
        IndexBufferFormat GetFormat() { return m_Format; }
                          ^
src/Nexus/src/Nexus-Core/Graphics/GPUBuffer.hpp:108:34: style:inconclusive: Technically the member function 'Nexus::Graphics::UniformBuffer::GetDescription' can be const. [functionConst]
        const BufferDescription &GetDescription() { return m_Description; }
                                 ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:91:13: style:inconclusive: Technically the member function 'Nexus::Graphics::Framebuffer::GetColorTextureCount' can be const. [functionConst]
        int GetColorTextureCount() { return m_Specification.ColorAttachmentSpecification.Attachments.size(); }
            ^
src/Nexus/src/Nexus-Core/Graphics/Swapchain.hpp:30:39: style:inconclusive: Technically the member function 'Nexus::Graphics::Swapchain::GetSpecification' can be const. [functionConst]
        const SwapchainSpecification &GetSpecification()
                                      ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:48:26: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::GetType' can be const. [functionConst]
        RenderTargetType GetType()
                         ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:107:14: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::IsValid' can be const. [functionConst]
        bool IsValid()
             ^
src/Nexus/src/Nexus-Core/Graphics/RenderTarget.hpp:112:24: style:inconclusive: Technically the member function 'Nexus::Graphics::RenderTarget::operator==' can be const. [functionConst]
        constexpr bool operator==(const RenderTarget &other)
                       ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.hpp:72:21: style:inconclusive: Technically the member function 'Nexus::Graphics::GraphicsDevice::GetGraphicsAPI' can be const. [functionConst]
        GraphicsAPI GetGraphicsAPI() { return this->m_API; }
                    ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < uint32_t >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < int >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:66:9: style: Struct 'Point3D' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point3D(T x)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:22:9: style: Struct 'FramebufferTextureSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferTextureSpecification(PixelFormat format)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:37:9: style: Struct 'FramebufferColorAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferColorAttachmentSpecification(std::initializer_list<FramebufferTextureSpecification> attachments)
        ^
src/Nexus/src/Nexus-Core/Graphics/Framebuffer.hpp:52:9: style: Struct 'FramebufferDepthAttachmentSpecification' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FramebufferDepthAttachmentSpecification(PixelFormat format)
        ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < uint32_t >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Application.cpp:623:32: style: Variable 'indexToRemove' is assigned a value that is never used. [unreadVariable]
        uint32_t indexToRemove = 0;
                               ^
src/Nexus/src/Nexus-Core/AssetManager.hpp:17:9: style: Class 'AssetManager' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AssetManager(Graphics::GraphicsDevice *graphicsDevice) : m_GraphicsDevice(graphicsDevice) {}
        ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:10:52: performance: Function parameter 'filters' should be passed by const reference. [passedByValue]
    const char *OpenFile(std::vector<const char *> filters)
                                                   ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:22:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
src/Nexus/src/Nexus-Core/FileSystem/FileDialogs.cpp:32:9: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return "";
        ^
src/Nexus/src/Nexus-Core/Graphics/Font.hpp:91:46: style:inconclusive: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const. [functionConst]
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
src/Nexus/src/Nexus-Core/Graphics/Font.cpp:140:48: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
    Nexus::Ref<Nexus::Graphics::Texture> Font::GetTexture()
                                               ^
src/Nexus/src/Nexus-Core/Graphics/Font.hpp:91:46: note: Technically the member function 'Nexus::Graphics::Font::GetTexture' can be const.
        Nexus::Ref<Nexus::Graphics::Texture> GetTexture();
                                             ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:13:27: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const. [functionConst]
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:32:39: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
    Ref<VertexBuffer> FullscreenQuad::GetVertexBuffer()
                                      ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:13:27: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBuffer' can be const.
        Ref<VertexBuffer> GetVertexBuffer();
                          ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:14:26: style:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const. [functionConst]
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:37:38: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
    Ref<IndexBuffer> FullscreenQuad::GetIndexBuffer()
                                     ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:14:26: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetIndexBuffer' can be const.
        Ref<IndexBuffer> GetIndexBuffer();
                         ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:16:45: performance:inconclusive: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.cpp:42:57: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
    Nexus::Graphics::VertexBufferLayout FullscreenQuad::GetVertexBufferLayout()
                                                        ^
src/Nexus/src/Nexus-Core/Graphics/FullscreenQuad.hpp:16:45: note: Technically the member function 'Nexus::Graphics::FullscreenQuad::GetVertexBufferLayout' can be static (but you may consider moving to unnamed namespace).
        Nexus::Graphics::VertexBufferLayout GetVertexBufferLayout();
                                            ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:20:9: performance: Variable 'm_API' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_API = createInfo.API;
        ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:52:24: style: Variable 'totalTime' is assigned a value that is never used. [unreadVariable]
        auto totalTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
                       ^
src/Nexus/src/Nexus-Core/Graphics/GraphicsDevice.cpp:37:21: style: Unused variable: errorMessage [unusedVariable]
        std::string errorMessage;
                    ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:76:50: style:inconclusive: Boolean expression 'language==ShaderLanguage::GLSL' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.hpp:74:27: performance:inconclusive: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:291:40: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
    CompilationResult ShaderGenerator::Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources)
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.hpp:74:27: note: Technically the member function 'Nexus::Graphics::ShaderGenerator::Generate' can be static (but you may consider moving to unnamed namespace).
        CompilationResult Generate(const std::string &source, ShaderGenerationOptions options, ResourceSetSpecification &resources);
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:76:50: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
            if (language == ShaderLanguage::GLSL | language == ShaderLanguage::GLSLES)
                                                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:321:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:321:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:333:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:333:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:345:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:345:39: note: Shadow variable
            spirv_cross::CompilerHLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:369:39: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:369:39: note: Shadow variable
            spirv_cross::CompilerGLSL compiler(spirv_binary);
                                      ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:385:31: style: Local variable 'compiler' shadows outer variable [shadowVariable]
            shaderc::Compiler compiler;
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:300:27: note: Shadowed declaration
        shaderc::Compiler compiler;
                          ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:385:31: note: Shadow variable
            shaderc::Compiler compiler;
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:386:18: style: Local variable 'shaderType' shadows outer variable [shadowVariable]
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:301:14: note: Shadowed declaration
        auto shaderType = GetTypeOfShader(options.Stage);
             ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:386:18: note: Shadow variable
            auto shaderType = GetTypeOfShader(options.Stage);
                 ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:387:40: style: Local variable 'result' shadows outer variable [shadowVariable]
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:302:36: note: Shadowed declaration
        shaderc::CompilationResult result = compiler.CompileGlslToSpv(source, shaderType, options.ShaderName.c_str());
                                   ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:387:40: note: Shadow variable
            shaderc::CompilationResult result = compiler.CompileGlslToSpv(output.Source, shaderType, options.ShaderName.c_str());
                                       ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:389:35: style: Local variable 'spirv_binary' shadows outer variable [shadowVariable]
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:310:31: note: Shadowed declaration
        std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                              ^
src/Nexus/src/Nexus-Core/Graphics/ShaderGenerator.cpp:389:35: note: Shadow variable
            std::vector<uint32_t> spirv_binary = {result.begin(), result.end()};
                                  ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:35:33: style:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::GetPipeline' can be const. [functionConst]
        Ref<Graphics::Pipeline> GetPipeline() { return m_Pipeline; }
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:44:14: performance:inconclusive: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void UpdateMonitors();
             ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:719:33: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
    void ImGuiGraphicsRenderer::UpdateMonitors()
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:44:14: note: Technically the member function 'Nexus::ImGuiUtils::ImGuiGraphicsRenderer::UpdateMonitors' can be static (but you may consider moving to unnamed namespace).
        void UpdateMonitors();
             ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.hpp:25:9: style: Class 'ImGuiGraphicsRenderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ImGuiGraphicsRenderer(Nexus::Application *app);
        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:205:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:217:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:230:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:243:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:256:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:269:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:283:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:296:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:308:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:321:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:336:41: style: C-style pointer casting [cstyleCast]
                ImGuiWindowInfo *info = (ImGuiWindowInfo *)vp->PlatformUserData;
                                        ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:431:45: style: C-style pointer casting [cstyleCast]
                    ImGuiWindowInfo *info = (ImGuiWindowInfo *)platform_io.Viewports[i]->PlatformUserData;
                                            ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:599:33: style: C-style pointer casting [cstyleCast]
        ImGuiWindowInfo *info = (ImGuiWindowInfo *)drawData->OwnerViewport->PlatformUserData;
                                ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:539:56: style: Variable 'layout' is assigned a value that is never used. [unreadVariable]
            Nexus::Graphics::VertexBufferLayout layout =
                                                       ^
src/Nexus/src/Nexus-Core/ImGui/ImGuiGraphicsRenderer.cpp:617:27: style: Variable 'vp' is assigned a value that is never used. [unreadVariable]
        ImGuiViewport *vp = drawData->OwnerViewport;
                          ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:164:24: style:inconclusive: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const. [functionConst]
        const uint32_t GetControllerIndex();
                       ^
src/Nexus/src/Nexus-Core/Input/Gamepad.cpp:199:29: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
    const uint32_t Gamepad::GetControllerIndex()
                            ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:164:24: note: Technically the member function 'Nexus::Gamepad::GetControllerIndex' can be const.
        const uint32_t GetControllerIndex();
                       ^
src/Nexus/src/Nexus-Core/Input/Gamepad.hpp:93:9: style: Class 'Gamepad' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Gamepad(uint32_t index);
        ^
src/Nexus/src/Nexus-Core/Input/Mouse.hpp:37:5: style: The class 'Mouse' does not have a constructor although it has private member variables. [noConstructor]
    class Mouse
    ^
src/Nexus/src/Nexus-Core/Input/InputState.hpp:19:5: style: The class 'InputState' does not have a constructor although it has private member variables. [noConstructor]
    class InputState
    ^
src/Nexus/src/Nexus-Core/Input/Input.hpp:176:14: performance:inconclusive: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Input.cpp:234:17: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
    void Input::CacheInput()
                ^
src/Nexus/src/Nexus-Core/Input/Input.hpp:176:14: note: Technically the member function 'Nexus::Input::CacheInput' can be static (but you may consider moving to unnamed namespace).
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Keyboard.hpp:133:14: style:inconclusive: Technically the member function 'Nexus::Keyboard::CacheInput' can be const. [functionConst]
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Input/Keyboard.cpp:5:20: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
    void Keyboard::CacheInput()
                   ^
src/Nexus/src/Nexus-Core/Input/Keyboard.hpp:133:14: note: Technically the member function 'Nexus::Keyboard::CacheInput' can be const.
        void CacheInput();
             ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:67:28: style: Unused private function: 'Logger::GetTime' [unusedPrivateFunction]
        static std::string GetTime();
                           ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:62:40: style:inconclusive: Technically the member function 'Nexus::Logger::GetLogs' can be const. [functionConst]
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
src/Nexus/src/Nexus-Core/Logging/Log.cpp:64:44: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
    const std::vector<Nexus::Log> &Logger::GetLogs()
                                           ^
src/Nexus/src/Nexus-Core/Logging/Log.hpp:62:40: note: Technically the member function 'Nexus::Logger::GetLogs' can be const.
        const std::vector<Nexus::Log> &GetLogs();
                                       ^
src/Nexus/src/Nexus-Core/Renderer.hpp:17:14: performance:inconclusive: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void End();
             ^
src/Nexus/src/Nexus-Core/Renderer.cpp:10:20: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
    void Renderer::End()
                   ^
src/Nexus/src/Nexus-Core/Renderer.hpp:17:14: note: Technically the member function 'Nexus::Renderer::End' can be static (but you may consider moving to unnamed namespace).
        void End();
             ^
src/Nexus/src/Nexus-Core/Renderer.hpp:28:9: style: Class 'Renderer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Renderer(Graphics::GraphicsDevice *device);
        ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:106:50: style:inconclusive: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list. [initializerList]
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.cpp:513:53: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        : m_Device(device), m_RenderTarget(target), m_CommandList(m_Device->CreateCommandList())
                                                    ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:106:50: note: Member variable 'BatchRenderer::m_CommandList' is in the wrong place in the initializer list.
        Nexus::Ref<Nexus::Graphics::CommandList> m_CommandList = nullptr;
                                                 ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:100:14: style:inconclusive: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const. [functionConst]
        void EnsureStarted();
             ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.cpp:1150:25: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
    void BatchRenderer::EnsureStarted()
                        ^
src/Nexus/src/Nexus-Core/Renderer/BatchRenderer.hpp:100:14: note: Technically the member function 'Nexus::Graphics::BatchRenderer::EnsureStarted' can be const.
        void EnsureStarted();
             ^
src/Nexus/src/Nexus-Core/Point.hpp:35:14: style:inconclusive: Technically the member function 'Point2D < float >::Deconstruct' can be const. [functionConst]
        void Deconstruct(T *x, T *y)
             ^
src/Nexus/src/Nexus-Core/Point.hpp:20:9: style: Struct 'Point2D < float >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Point2D(T x)
        ^
src/Nexus/src/Nexus-Core/Runtime/Entity.hpp:20:14: performance:inconclusive: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        bool Deserialize(YAML::Node &data);
             ^
src/Nexus/src/Nexus-Core/Runtime/Entity.cpp:38:18: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
    bool Entity::Deserialize(YAML::Node &data)
                 ^
src/Nexus/src/Nexus-Core/Runtime/Entity.hpp:20:14: note: Technically the member function 'Nexus::Entity::Deserialize' can be static (but you may consider moving to unnamed namespace).
        bool Deserialize(YAML::Node &data);
             ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:17:9: performance: Variable 'm_SceneDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SceneDirectory = "\\Scenes";
        ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:18:9: performance: Variable 'm_AssetsDirectory' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_AssetsDirectory = "\\Assets";
        ^
src/Nexus/src/Nexus-Core/Runtime/Project.hpp:36:14: style:inconclusive: Technically the member function 'Nexus::Project::WriteProjectFile' can be const. [functionConst]
        void WriteProjectFile();
             ^
src/Nexus/src/Nexus-Core/Runtime/Project.cpp:97:19: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
    void Project::WriteProjectFile()
                  ^
src/Nexus/src/Nexus-Core/Runtime/Project.hpp:36:14: note: Technically the member function 'Nexus::Project::WriteProjectFile' can be const.
        void WriteProjectFile();
             ^
src/Nexus/src/Nexus-Core/Runtime/Scene.hpp:23:14: style:inconclusive: Technically the member function 'Nexus::Scene::Serialize' can be const. [functionConst]
        void Serialize(const std::string &filepath);
             ^
src/Nexus/src/Nexus-Core/Runtime/Scene.cpp:119:17: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
    void Scene::Serialize(const std::string &filepath)
                ^
src/Nexus/src/Nexus-Core/Runtime/Scene.hpp:23:14: note: Technically the member function 'Nexus::Scene::Serialize' can be const.
        void Serialize(const std::string &filepath);
             ^
src/Nexus/src/Nexus-Core/UI/Canvas.cpp:9:9: performance: Variable 'm_BatchRenderer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_BatchRenderer = std::make_unique<Nexus::Graphics::BatchRenderer>(device, Nexus::Graphics::RenderTarget{swapchain});
        ^
src/Nexus/src/Nexus-Core/Vertex.hpp:46:9: style: Struct 'VertexBufferLayout' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexBufferLayout(std::initializer_list<VertexBufferElement> elements)
        ^
src/Nexus/src/Nexus-Core/Vertex.hpp:111:9: style: Struct 'VertexPosition' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        VertexPosition(const glm::vec3 &position)
        ^
src/Nexus/src/Nexus-Core/Window.hpp:80:14: style:inconclusive: Technically the member function 'Nexus::Window::IsClosing' can be const. [functionConst]
        bool IsClosing();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:68:18: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
    bool Window::IsClosing()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:80:14: note: Technically the member function 'Nexus::Window::IsClosing' can be const.
        bool IsClosing();
             ^
src/Nexus/src/Nexus-Core/Window.hpp:100:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetIsMouseVisible(bool visible);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:122:18: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
    void Window::SetIsMouseVisible(bool visible)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:100:14: note: Technically the member function 'Nexus::Window::SetIsMouseVisible' can be static (but you may consider moving to unnamed namespace).
        void SetIsMouseVisible(bool visible);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:104:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetCursor(Cursor cursor);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:135:18: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
    void Window::SetCursor(Cursor cursor)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:104:14: note: Technically the member function 'Nexus::Window::SetCursor' can be static (but you may consider moving to unnamed namespace).
        void SetCursor(Cursor cursor);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:108:27: style:inconclusive: Technically the member function 'Nexus::Window::GetInput' can be const. [functionConst]
        const InputState *GetInput();
                          ^
src/Nexus/src/Nexus-Core/Window.cpp:182:31: note: Technically the member function 'Nexus::Window::GetInput' can be const.
    const InputState *Window::GetInput()
                              ^
src/Nexus/src/Nexus-Core/Window.hpp:108:27: note: Technically the member function 'Nexus::Window::GetInput' can be const.
        const InputState *GetInput();
                          ^
src/Nexus/src/Nexus-Core/Window.hpp:153:18: style:inconclusive: Technically the member function 'Nexus::Window::GetID' can be const. [functionConst]
        uint32_t GetID();
                 ^
src/Nexus/src/Nexus-Core/Window.cpp:298:22: note: Technically the member function 'Nexus::Window::GetID' can be const.
    uint32_t Window::GetID()
                     ^
src/Nexus/src/Nexus-Core/Window.hpp:153:18: note: Technically the member function 'Nexus::Window::GetID' can be const.
        uint32_t GetID();
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:157:14: performance:inconclusive: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
src/Nexus/src/Nexus-Core/Window.cpp:308:18: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
    void Window::SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect)
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:157:14: note: Technically the member function 'Nexus::Window::SetTextInputRect' can be static (but you may consider moving to unnamed namespace).
        void SetTextInputRect(const Nexus::Graphics::Rectangle<int> &rect);
             ^
src/Nexus/src/Nexus-Core/Window.hpp:158:14: performance:inconclusive: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StartTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:318:18: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StartTextInput()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:158:14: note: Technically the member function 'Nexus::Window::StartTextInput' can be static (but you may consider moving to unnamed namespace).
        void StartTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.hpp:159:14: performance:inconclusive: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void StopTextInput();
             ^
src/Nexus/src/Nexus-Core/Window.cpp:322:18: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
    void Window::StopTextInput()
                 ^
src/Nexus/src/Nexus-Core/Window.hpp:159:14: note: Technically the member function 'Nexus::Window::StopTextInput' can be static (but you may consider moving to unnamed namespace).
        void StopTextInput();
             ^
src/Nexus/src/Platform/D3D12/TimingQueryD3D12.hpp:14:9: style: Class 'TimingQueryD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryD3D12(GraphicsDeviceD3D12 *device);
        ^
src/Nexus/src/Platform/D3D12/CommandExecutorD3D12.cpp:170:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)command.Target.GetData<Swapchain *>();
                                  ^
src/Nexus/src/Platform/D3D12/CommandExecutorD3D12.cpp:228:31: style: C-style pointer casting [cstyleCast]
        auto swapchainD3D12 = (SwapchainD3D12 *)command.Target;
                              ^
src/Nexus/src/Platform/D3D12/CommandExecutorD3D12.cpp:418:35: style: C-style pointer casting [cstyleCast]
            auto d3d12Swapchain = (SwapchainD3D12 *)m_CurrentRenderTarget.GetData<Swapchain *>();
                                  ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.hpp:17:9: style: Class 'CommandListD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListD3D12(GraphicsDeviceD3D12 *device);
        ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:49:54: style:inconclusive: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'. [funcArgNamesDifferent]
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.hpp:25:48: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
        virtual void SetPipeline(Ref<Pipeline> ipeline) override;
                                               ^
src/Nexus/src/Platform/D3D12/CommandListD3D12.cpp:49:54: note: Function 'SetPipeline' argument 1 names different: declaration 'ipeline' definition 'pipeline'.
    void CommandListD3D12::SetPipeline(Ref<Pipeline> pipeline)
                                                     ^
src/Nexus/src/Platform/D3D12/FramebufferD3D12.cpp:61:26: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        auto d3d12Device = m_Device->GetDevice();
                         ^
src/Nexus/src/Platform/D3D12/SamplerD3D12.hpp:13:9: style: Class 'SamplerD3D12' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerD3D12(const SamplerSpecification &spec);
        ^
src/Nexus/src/Platform/D3D12/GraphicsDeviceD3D12.cpp:22:37: style: Variable 'experimentalFeatures' is assigned a value that is never used. [unreadVariable]
        UUID experimentalFeatures[] = {D3D12ExperimentalShaderModels};
                                    ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.hpp:35:29: style:inconclusive: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list. [initializerList]
        PipelineDescription m_Description;
                            ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.cpp:14:52: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        : Pipeline(description), m_Device(device), m_Description(description)
                                                   ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.hpp:35:29: note: Member variable 'PipelineD3D12::m_Description' is in the wrong place in the initializer list.
        PipelineDescription m_Description;
                            ^
src/Nexus/src/Platform/D3D12/PipelineD3D12.cpp:161:30: style: C-style pointer casting [cstyleCast]
            auto swapchain = (SwapchainD3D12 *)m_Description.Target.GetData<Swapchain *>();
                             ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:142:18: style: Local variable 'd3d12Device' shadows outer variable [shadowVariable]
            auto d3d12Device = m_Device->GetDevice();
                 ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:114:20: note: Shadowed declaration
        const auto d3d12Device = m_Device->GetDevice();
                   ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:142:18: note: Shadow variable
            auto d3d12Device = m_Device->GetDevice();
                 ^
src/Nexus/src/Platform/D3D12/ResourceSetD3D12.cpp:20:38: style: Variable 'constantBufferCount' is assigned a value that is never used. [unreadVariable]
        uint32_t constantBufferCount = spec.UniformBuffers.size();
                                     ^
src/Nexus/src/Platform/D3D12/SamplerD3D12.cpp:12:9: performance: Variable 'm_SamplerFilter' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_SamplerFilter = GetD3D12Filter(spec.SampleFilter);
        ^
src/Nexus/src/Platform/D3D12/ShaderModuleD3D12.cpp:67:26: style: Variable 'hr' is assigned a value that is never used. [unreadVariable]
        const HRESULT hr = compiler->Compile(
                         ^
src/Nexus/src/Platform/D3D12/SwapchainD3D12.cpp:15:20: style: C-style pointer casting [cstyleCast]
        m_Device = (GraphicsDeviceD3D12 *)device;
                   ^
src/Nexus/src/Platform/D3D12/TimingQueryD3D12.cpp:10:37: style: Variable 'd3d12Device' is assigned a value that is never used. [unreadVariable]
        ID3D12Device10 *d3d12Device = m_Device->GetDevice();
                                    ^
src/Nexus/src/Platform/OpenAL/AudioSourceOpenAL.hpp:17:9: style: Class 'AudioSourceOpenAL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        AudioSourceOpenAL(Ref<AudioBuffer> buffer);
        ^
src/Nexus/src/Platform/OpenAL/AudioDeviceOpenAL.cpp:89:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
src/Nexus/src/Platform/OpenAL/AudioDeviceOpenAL.cpp:105:28: style: Variable 'bitsPerSample' is assigned a value that is never used. [unreadVariable]
        auto bitsPerSample = nqr::GetFormatBitsPerSample(data.sourceFormat);
                           ^
src/Nexus/src/Platform/OpenAL/AudioSourceOpenAL.cpp:11:9: performance: Variable 'm_Buffer' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        m_Buffer = buffer;
        ^
src/Nexus/src/Platform/OpenGL/PipelineOpenGL.hpp:13:9: style: Class 'PipelineOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        PipelineOpenGL(const PipelineDescription &description);
        ^
src/Nexus/src/Platform/OpenGL/TextureOpenGL.hpp:13:9: style: Class 'TextureOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TextureOpenGL(const TextureSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/ResourceSetOpenGL.hpp:17:9: style: Class 'ResourceSetOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ResourceSetOpenGL(const ResourceSetSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.cpp:294:42: style: C-style pointer casting [cstyleCast]
        GraphicsDeviceOpenGL *deviceGL = (GraphicsDeviceOpenGL *)device;
                                         ^
src/Nexus/src/Platform/OpenGL/CommandExecutorOpenGL.cpp:358:38: style: C-style pointer casting [cstyleCast]
        SwapchainOpenGL *swapchain = (SwapchainOpenGL *)command.Target;
                                     ^
src/Nexus/src/Platform/OpenGL/CommandListOpenGL.hpp:19:9: style: Class 'CommandListOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListOpenGL(GraphicsDevice *device);
        ^
src/Nexus/src/Platform/OpenGL/SamplerOpenGL.hpp:12:9: style: Class 'SamplerOpenGL' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SamplerOpenGL(const SamplerSpecification &spec);
        ^
src/Nexus/src/Platform/OpenGL/GraphicsDeviceOpenGL.cpp:158:28: style: C-style pointer casting [cstyleCast]
        auto glSwapchain = (SwapchainOpenGL *)swapchain;
                           ^
src/Nexus/src/Platform/Vulkan/TimingQueryVk.hpp:14:9: style: Class 'TimingQueryVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TimingQueryVk(GraphicsDeviceVk *device);
        ^
src/Nexus/src/Platform/Vulkan/CommandExecutorVk.cpp:270:36: style: C-style pointer casting [cstyleCast]
            auto vulkanSwapchain = (SwapchainVk *)swapchain;
                                   ^
src/Nexus/src/Platform/Vulkan/CommandExecutorVk.cpp:407:28: style: C-style pointer casting [cstyleCast]
        auto swapchainVk = (SwapchainVk *)command.Target;
                           ^
src/Nexus/src/Platform/Vulkan/CommandListVk.hpp:16:9: style: Class 'CommandListVk' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandListVk(GraphicsDeviceVk *graphicsDevice);
        ^
src/Nexus/src/Platform/Vulkan/FramebufferVk.cpp:113:25: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            attachments.push_back(texture->GetImageView());
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:37:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:191:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:421:38: style: C-style pointer casting [cstyleCast]
            SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                     ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:509:34: style: C-style pointer casting [cstyleCast]
        SwapchainVk *swapchain = (SwapchainVk *)m_Window->GetSwapchain();
                                 ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:749:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:746:25: note: result is initialized
        VkResult result = vkEnumerateInstanceExtensionProperties(nullptr, &count, nullptr);
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:749:16: note: result is overwritten
        result = vkEnumerateInstanceExtensionProperties(nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:779:16: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:776:25: note: result is initialized
        VkResult result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, nullptr);
                        ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:779:16: note: result is overwritten
        result = vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &count, properties.data());
               ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:759:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:789:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            extensions.push_back(property.extensionName);
                       ^
src/Nexus/src/Platform/Vulkan/GraphicsDeviceVk.cpp:34:31: style: Variable 'deviceExtensions' is assigned a value that is never used. [unreadVariable]
        auto deviceExtensions = GetSupportedDeviceExtensions();
                              ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:154:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:251:32: style: C-style pointer casting [cstyleCast]
            auto swapchainVk = (SwapchainVk *)m_Description.Target.GetData<Swapchain *>();
                               ^
src/Nexus/src/Platform/Vulkan/PipelineVk.cpp:19:21: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            layouts.push_back(layout.second);
                    ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:30:44: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[textureBinding.Set] = {};
                                           ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:36:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:55:50: performance: Searching before insertion is not necessary. [stlFindInsert]
                sets[uniformBufferBinding.Set] = {};
                                                 ^
src/Nexus/src/Platform/Vulkan/ResourceSetVk.cpp:61:70: performance: Searching before insertion is not necessary. [stlFindInsert]
                descriptorCounts[descriptorBinding.descriptorType] = 0;
                                                                     ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:39:32: style: Variable 'samplerInfo.mipLodBias' is reassigned a value before the old one has been used. [redundantAssignment]
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:38:32: note: samplerInfo.mipLodBias is assigned
        samplerInfo.mipLodBias = mipmapMode;
                               ^
src/Nexus/src/Platform/Vulkan/SamplerVk.cpp:39:32: note: samplerInfo.mipLodBias is overwritten
        samplerInfo.mipLodBias = spec.LODBias;
                               ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:23:28: style: C-style pointer casting [cstyleCast]
        m_GraphicsDevice = (GraphicsDeviceVk *)graphicsDevice;
                           ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:253:39: style: Variable 'queueFamilyIndices' is assigned a value that is never used. [unreadVariable]
        uint32_t queueFamilyIndices[] = {m_GraphicsDevice->m_GraphicsQueueFamilyIndex, m_GraphicsDevice->m_PresentQueueFamilyIndex};
                                      ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:256:24: style: Variable 'imageCount' is assigned a value that is never used. [unreadVariable]
            imageCount = m_SurfaceCapabilities.maxImageCount;
                       ^
src/Nexus/src/Platform/Vulkan/SwapchainVk.cpp:291:35: style: Variable 'validDepthFormat' is assigned a value that is never used. [unreadVariable]
        VkBool32 validDepthFormat = GetSupportedDepthFormat(m_GraphicsDevice->m_PhysicalDevice, &m_DepthFormat);
                                  ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:73:25: style: Redundant initialization for 'aspectFlags'. The initialized value is overwritten before it is read. [redundantInitialization]
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:70:43: note: aspectFlags is initialized
        VkImageAspectFlagBits aspectFlags = {};
                                          ^
src/Nexus/src/Platform/Vulkan/TextureVk.cpp:73:25: note: aspectFlags is overwritten
            aspectFlags = VkImageAspectFlagBits(VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
                        ^
src/Nexus/src/Platform/Vulkan/Vk.cpp:474:21: style: Consider using std::any_of, std::all_of, std::none_of, or std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            isDepth = true;
                    ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

